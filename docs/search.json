[
  {
    "objectID": "hierarchical_models.html",
    "href": "hierarchical_models.html",
    "title": "Hierarchical models",
    "section": "",
    "text": "In general: a model with hyperparameters, i.e. parameters that describe other parameters.\nHierarchical models are great for describing the situation where you know some measurements have something in common, but you don’t know how much.",
    "crumbs": [
      "Course materials",
      "Hierarchical models"
    ]
  },
  {
    "objectID": "hierarchical_models.html#example-always-be-closing",
    "href": "hierarchical_models.html#example-always-be-closing",
    "title": "Hierarchical models",
    "section": "Example: always be closing!",
    "text": "Example: always be closing!\nPlushycorp employs 10 salespeople who go door to door selling cute plushies. The number of plushies that each salesperson sold every working day for two weeks was recorded. What can Plushycorp find out from this data?\nTo answer the question in a best-case scenario, we can use a hierarchical model to run a “digital twin” of this experiment with known parameters and data generating process. Specifically, we can assume that the number \\(y_{ij}\\) of plushies that salesperson \\(i\\) sells on day \\(j\\) depends on a combination of factors:\n\nThe baseline amount \\(\\mu\\) that a totally average salesperson would sell on a normal day\nThe salesperson’s ability \\(ability_i\\)\nAn effect \\(day\\ effect_j\\) for the day of the week: people are thought to buy fewer and fewer plushies as the week drags on.\nSome random variation\n\nA good first step for modelling count data is the Poisson distribution, so let’s assume that the sales measurements follow the following Poisson distribution:1\n1 Note the use of the log link function.\\[\\begin{align*}\ny_{ij} &\\sim Poisson(\\lambda) \\\\\n\\ln\\lambda &= \\mu + ability_i + day\\ effect_j\n\\end{align*}\\]\nWe know that the salespeople have different abilities, but how just different are they? Since this isn’t really clear to Plushycorp, it makes sense to introduce a parameter \\(\\tau_{ability}\\) into the model:\n\\[\\begin{equation*}\nability \\sim N(0, \\tau^{ability})\n\\end{equation*}\\]\nNow we have a hierarchical model!\nWe can make a similar argument for the day of the week effects:2\n2 Can you think of a better model for day effects given the information above??\\[\\begin{equation*}\nday\\ effect \\sim N(0, \\tau^{day})\n\\end{equation*}\\]\nFinally we can complete our model by specifying prior distributions for the non-hierarchical parameters:3\n3 \\(HN\\) here refers to the “half-normal” distribution, a decent default prior for hierarchical standard deviations\\[\\begin{align*}\n\\mu &\\sim LN(0, 1) \\\\\n\\tau_ability &\\sim HN(0, 1) \\\\\n\\tau_day &\\sim HN(0, 1)\n\\end{align*}\\]\nTo test out our model with fake data, we can use Python to generate a fake set of salespeople and days, then generate some sales consistently with our model. Next we can generate some data,\n\nfrom pathlib import Path\nimport json\nimport numpy as np\nimport pandas as pd\n\nN_SALESPERSON = 10\nN_WEEK = 2\nDAY_NAMES = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"]\nBASELINE = 2  # 2 plushies in one day is fine\nTAU_ABILITY = 0.35\nTAU_DAY = 0.2\n\nSEED = 12345\nDATA_DIR = Path(\"../data\")\n\nrng = np.random.default_rng(seed=SEED)\n\nwith open(DATA_DIR / \"names.json\", \"r\") as f:\n    name_directory = json.load(f)\n\nnames = [\n    f\"{first_name} {surname}\"\n    for first_name, surname in zip(\n        *map(\n            lambda l: rng.choice(l, size=N_SALESPERSON, replace=False),\n            name_directory.values()\n        )\n    )\n]\n\nabilities = rng.normal(loc=0, scale=TAU_ABILITY, size=N_SALESPERSON)\n\nsalespeople = pd.DataFrame({\"salesperson\": names, \"ability\": abilities})\n\nsalespeople\n\n\n\n\n\n\n\n\n\nsalesperson\nability\n\n\n\n\n0\nMorten Andersen\n0.489643\n\n\n1\nLene Poulsen\n0.462804\n\n\n2\nRasmus Jensen\n-0.104894\n\n\n3\nHanne Madsen\n0.316022\n\n\n4\nMette Rasmussen\n-0.567554\n\n\n5\nChristian Christensen\n-0.055366\n\n\n6\nHelle Kristensen\n0.157319\n\n\n7\nCharlotte Hansen\n-0.470260\n\n\n8\nMaria Petersen\n-0.028591\n\n\n9\nJette Thomsen\n0.603659\n\n\n\n\n\n\n\n\n\nday_effects = sorted(\n    rng.normal(loc=0, scale=TAU_DAY, size=len(DAY_NAMES))\n)[::-1]  # This (i.e. `[::-1]`) is a nice way to reverse a list\ndays = pd.DataFrame({\"day\": DAY_NAMES, \"day_effect\": day_effects})\ndays\n\n\n\n\n\n\n\n\n\nday\nday_effect\n\n\n\n\n0\nMon\n0.523632\n\n\n1\nTue\n0.165727\n\n\n2\nWed\n0.155472\n\n\n3\nThu\n-0.191798\n\n\n4\nFri\n-0.241878\n\n\n\n\n\n\n\n\n\nsales = (\n    days\n    .merge(salespeople, how=\"cross\")\n    .merge(pd.DataFrame({\"week\":[1, 2, 3, 4]}), how=\"cross\")\n    .assign(\n        sales=lambda df: rng.poisson(\n            np.exp(np.log(BASELINE) + df[\"ability\"] + df[\"day_effect\"])\n        )\n    )\n    [[\"week\", \"day\", \"salesperson\", \"day_effect\", \"ability\", \"sales\"]]\n    .copy()\n)\nsales.head()\n\n\n\n\n\n\n\n\n\nweek\nday\nsalesperson\nday_effect\nability\nsales\n\n\n\n\n0\n1\nMon\nMorten Andersen\n0.523632\n0.489643\n10\n\n\n1\n2\nMon\nMorten Andersen\n0.523632\n0.489643\n3\n\n\n2\n3\nMon\nMorten Andersen\n0.523632\n0.489643\n4\n\n\n3\n4\nMon\nMorten Andersen\n0.523632\n0.489643\n4\n\n\n4\n1\nMon\nLene Poulsen\n0.523632\n0.462804\n4\n\n\n\n\n\n\n\n\nHere is the fortnightly sales chart\n\ntotal_sales = (\n    sales.groupby(\"salesperson\")[\"sales\"].sum().sort_values(ascending=False)\n)\n\ntotal_sales.plot(kind=\"bar\", ylabel=\"Plushies sold\", title=\"Fortnightly sales\")\n\n\n\n\n\n\n\n\nIt’s pretty straightforward to represent hierarchical models with Stan, almost like Stan was designed for it!\n\nfrom cmdstanpy import CmdStanModel\n\nmodel = CmdStanModel(stan_file=\"../src/stan/plushies.stan\")\nprint(model.code())\n\ndata {\n int&lt;lower=1&gt; N;\n int&lt;lower=1&gt; N_salesperson;\n int&lt;lower=1&gt; N_day;\n array[N] int&lt;lower=1,upper=N_salesperson&gt; salesperson;\n array[N] int&lt;lower=1,upper=N_day&gt; day;\n array[N] int&lt;lower=0&gt; sales;\n int&lt;lower=0,upper=1&gt; likelihood;\n}\nparameters {\n real log_mu;\n vector[N_salesperson] ability;\n vector[N_day] day_effect;\n real&lt;lower=0&gt; tau_ability;\n real&lt;lower=0&gt; tau_day;\n}\ntransformed parameters {\n vector[N] log_lambda = log_mu + ability[salesperson] + day_effect[day]; \n}\nmodel {\n  log_mu ~ normal(0, 1);\n  ability ~ normal(0, tau_ability);\n  day_effect ~ normal(0, tau_day);\n  tau_ability ~ normal(0, 0.5);\n  tau_day ~ normal(0, 0.5);\n  if (likelihood){\n    sales ~ poisson_log(log_lambda);\n  }\n}\ngenerated quantities {\n real mu = exp(log_mu);\n vector[N] lambda = exp(log_lambda);\n array[N] int yrep = poisson_rng(lambda);\n vector[N] llik; \n for (n in 1:N){\n   llik[n] = poisson_lpmf(sales[n] | lambda[n]);\n }\n}\n\n\n\n\n\nimport arviz as az\nfrom stanio.json import process_dictionary\n\ndef one_encode(l):\n    \"\"\"One-encode a 1d list-like thing.\"\"\"\n    return dict(zip(l, range(1, len(l) + 1)))\n\n\nsalesperson_codes = one_encode(salespeople[\"salesperson\"])\nday_codes = one_encode(days[\"day\"])\ndata_prior = process_dictionary({\n        \"N\": len(sales),\n        \"N_salesperson\": len(salespeople),\n        \"N_day\": len(days),\n        \"salesperson\": sales[\"salesperson\"].map(salesperson_codes),\n        \"day\": sales[\"day\"].map(day_codes),\n        \"sales\": sales[\"sales\"],\n        \"likelihood\": 0\n    }\n)\ndata_posterior = data_prior | {\"likelihood\": 1}\nmcmc_prior = model.sample(data=data_prior)\nmcmc_posterior = model.sample(data=data_posterior)\nidata = az.from_cmdstanpy(\n    posterior=mcmc_posterior,\n    prior=mcmc_prior,\n    log_likelihood=\"llik\",\n    posterior_predictive=\"yrep\",\n    observed_data=data_posterior,\n    coords={\n        \"salesperson\": salespeople[\"salesperson\"],\n        \"day\": days[\"day\"],\n        \"observation\": sales.index\n    },\n    dims={\n        \"lambda\": [\"observation\"],\n        \"ability\": [\"salesperson\"],\n        \"day_effect\": [\"day\"],\n        \"llik\": [\"observation\"],\n        \"yrep\": [\"observation\"]\n    }\n)\nidata\n\n17:48:16 - cmdstanpy - INFO - CmdStan start processing\n17:48:16 - cmdstanpy - INFO - CmdStan done processing.\n17:48:16 - cmdstanpy - WARNING - Non-fatal error during sampling:\nException: normal_lpdf: Scale parameter is 0, but must be positive! (in 'plushies.stan', line 22, column 2 to column 35)\nConsider re-running with show_console=True if the above output is unclear!\n17:48:16 - cmdstanpy - WARNING - Some chains may have failed to converge.\n    Chain 2 had 22 divergent transitions (2.2%)\n    Chain 3 had 13 divergent transitions (1.3%)\n    Chain 4 had 13 divergent transitions (1.3%)\n    Use the \"diagnose()\" method on the CmdStanMCMC object to see further information.\n17:48:16 - cmdstanpy - INFO - CmdStan start processing\n17:48:17 - cmdstanpy - INFO - CmdStan done processing.\n17:48:17 - cmdstanpy - WARNING - Non-fatal error during sampling:\nException: normal_lpdf: Scale parameter is 0, but must be positive! (in 'plushies.stan', line 23, column 2 to column 34)\nConsider re-running with show_console=True if the above output is unclear!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                                                                                                                                                                                                                                                                                \n                                                                                                                                                                                                                                                                                                                                \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            \n              \n                arviz.InferenceData\n              \n              \n              \n            \n                  \n                  posterior\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 13MB\nDimensions:           (chain: 4, draw: 1000, salesperson: 10, day: 5,\n                       log_lambda_dim_0: 200, observation: 200)\nCoordinates:\n  * chain             (chain) int64 32B 0 1 2 3\n  * draw              (draw) int64 8kB 0 1 2 3 4 5 6 ... 994 995 996 997 998 999\n  * salesperson       (salesperson) object 80B 'Morten Andersen' ... 'Jette T...\n  * day               (day) object 40B 'Mon' 'Tue' 'Wed' 'Thu' 'Fri'\n  * log_lambda_dim_0  (log_lambda_dim_0) int64 2kB 0 1 2 3 4 ... 196 197 198 199\n  * observation       (observation) int64 2kB 0 1 2 3 4 ... 195 196 197 198 199\nData variables:\n    log_mu            (chain, draw) float64 32kB 0.6904 0.9119 ... 1.321 1.296\n    ability           (chain, draw, salesperson) float64 320kB 0.565 ... 0.3127\n    day_effect        (chain, draw, day) float64 160kB 0.4165 ... -0.8173\n    tau_ability       (chain, draw) float64 32kB 0.3091 0.261 ... 0.3925 0.3837\n    tau_day           (chain, draw) float64 32kB 0.2309 0.2639 ... 0.9899 1.424\n    log_lambda        (chain, draw, log_lambda_dim_0) float64 6MB 1.672 ... 0...\n    mu                (chain, draw) float64 32kB 1.994 2.489 ... 3.746 3.653\n    lambda            (chain, draw, observation) float64 6MB 5.322 ... 2.206\nAttributes:\n    created_at:                 2024-04-12T15:48:17.803850\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000salesperson: 10day: 5log_lambda_dim_0: 200observation: 200Coordinates: (6)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])salesperson(salesperson)object'Morten Andersen' ... 'Jette Tho...array(['Morten Andersen', 'Lene Poulsen', 'Rasmus Jensen', 'Hanne Madsen',\n       'Mette Rasmussen', 'Christian Christensen', 'Helle Kristensen',\n       'Charlotte Hansen', 'Maria Petersen', 'Jette Thomsen'], dtype=object)day(day)object'Mon' 'Tue' 'Wed' 'Thu' 'Fri'array(['Mon', 'Tue', 'Wed', 'Thu', 'Fri'], dtype=object)log_lambda_dim_0(log_lambda_dim_0)int640 1 2 3 4 5 ... 195 196 197 198 199array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,\n        28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,\n        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,\n        56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,\n        70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,\n        84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n        98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n       112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,\n       126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n       140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\n       154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\n       168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n       182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\n       196, 197, 198, 199])observation(observation)int640 1 2 3 4 5 ... 195 196 197 198 199array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,\n        28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,\n        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,\n        56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,\n        70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,\n        84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n        98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n       112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,\n       126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n       140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\n       154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\n       168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n       182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\n       196, 197, 198, 199])Data variables: (8)log_mu(chain, draw)float640.6904 0.9119 1.006 ... 1.321 1.296array([[0.690364, 0.911878, 1.00604 , ..., 0.661583, 0.64593 , 0.709548],\n       [0.643108, 0.781063, 0.834006, ..., 0.80943 , 0.843507, 1.06315 ],\n       [0.959166, 0.914997, 0.78222 , ..., 0.860263, 0.953073, 0.948764],\n       [0.918547, 0.828938, 0.932746, ..., 1.34553 , 1.32065 , 1.29565 ]])ability(chain, draw, salesperson)float640.565 0.4083 ... -0.1879 0.3127array([[[ 5.65047e-01,  4.08345e-01, -6.03350e-02, ..., -3.35513e-01,\n         -2.67258e-01,  4.84049e-01],\n        [ 3.61036e-01,  3.99110e-01, -1.69447e-01, ..., -1.01467e-01,\n         -6.46967e-02,  4.04358e-01],\n        [ 5.04109e-01,  3.16439e-01, -3.08243e-01, ..., -6.32363e-01,\n         -1.71096e-01,  3.12077e-01],\n        ...,\n        [ 5.91185e-01,  3.78152e-01, -5.98136e-02, ..., -4.16449e-01,\n         -3.39863e-01,  7.70085e-01],\n        [ 6.19604e-01,  6.54037e-01, -1.60200e-02, ...,  6.28121e-02,\n         -1.17128e-01,  4.33881e-01],\n        [ 2.96045e-01,  4.05654e-01, -6.91319e-02, ..., -1.20843e-01,\n         -1.27862e-01,  7.12040e-01]],\n\n       [[ 6.93081e-01,  5.89890e-01, -4.28616e-03, ..., -5.23695e-01,\n         -1.06600e-01,  4.70279e-01],\n        [ 6.41088e-01,  5.39653e-01, -1.56207e-01, ..., -4.96303e-01,\n          1.26611e-01,  3.73974e-01],\n        [ 5.76988e-01,  5.95727e-01, -1.11459e-01, ..., -3.36300e-01,\n          6.03050e-02,  4.40132e-01],\n...\n        [ 3.01081e-01,  3.20132e-01, -1.37147e-04, ..., -2.09250e-01,\n         -7.92317e-02,  1.81121e-01],\n        [ 4.53334e-01,  4.05803e-01, -2.11532e-01, ..., -1.04001e-01,\n         -2.04713e-01,  4.15954e-01],\n        [ 5.05022e-01,  3.60835e-01, -1.11509e-01, ..., -1.35460e-01,\n         -2.49183e-01,  4.62193e-01]],\n\n       [[ 4.91505e-01,  2.99224e-01, -2.30822e-01, ..., -6.05699e-01,\n         -2.97650e-01,  3.39388e-01],\n        [ 5.12214e-01,  5.77841e-01, -1.58401e-01, ..., -1.68067e-01,\n         -5.21506e-02,  3.80347e-01],\n        [ 5.82786e-01,  2.05935e-01, -3.64288e-01, ..., -1.91478e-01,\n         -3.70869e-03,  4.54446e-01],\n        ...,\n        [ 5.40286e-02,  1.83583e-01, -4.22115e-01, ..., -5.97679e-01,\n         -3.95393e-01,  4.40910e-01],\n        [ 5.83049e-01,  3.24002e-01, -1.21171e-01, ..., -3.77516e-01,\n         -2.85896e-01,  1.14484e-01],\n        [ 5.65320e-01,  3.85936e-01, -1.69652e-01, ..., -4.09696e-01,\n         -1.87916e-01,  3.12738e-01]]])day_effect(chain, draw, day)float640.4165 0.05297 ... -0.812 -0.8173array([[[ 0.416525  ,  0.0529681 ,  0.199256  , -0.297681  ,\n         -0.135257  ],\n        [ 0.275108  , -0.0645061 , -0.0211499 , -0.435296  ,\n         -0.37932   ],\n        [ 0.0806154 ,  0.0261185 ,  0.0776595 , -0.444711  ,\n         -0.239714  ],\n        ...,\n        [ 0.332502  ,  0.0684294 ,  0.24232   , -0.150453  ,\n         -0.37618   ],\n        [ 0.354393  ,  0.141652  ,  0.046028  , -0.459696  ,\n         -0.029754  ],\n        [ 0.307484  ,  0.038602  ,  0.178593  , -0.176551  ,\n         -0.294999  ]],\n\n       [[ 0.31278   ,  0.29923   , -0.076864  , -0.513753  ,\n         -0.190685  ],\n        [ 0.28241   , -0.122057  ,  0.0130563 , -0.391472  ,\n         -0.306372  ],\n        [-0.100445  ,  0.061415  ,  0.0861189 , -0.505937  ,\n         -0.295871  ],\n...\n        [ 0.305441  ,  0.08431   , -0.00371548, -0.579039  ,\n         -0.059343  ],\n        [ 0.143846  , -0.0882541 ,  0.0132408 , -0.461182  ,\n         -0.577595  ],\n        [ 0.18833   , -0.0686221 ,  0.0442524 , -0.432577  ,\n         -0.569385  ]],\n\n       [[ 0.289902  ,  0.0620602 ,  0.104494  , -0.412341  ,\n         -0.0648103 ],\n        [ 0.300027  ,  0.0248569 ,  0.0896189 , -0.171056  ,\n         -0.357696  ],\n        [ 0.16243   , -0.148297  ,  0.00928022, -0.556043  ,\n         -0.215564  ],\n        ...,\n        [ 0.0681809 , -0.220457  , -0.566637  , -0.641637  ,\n         -0.395352  ],\n        [-0.214209  , -0.408893  , -0.0613924 , -0.825114  ,\n         -0.921002  ],\n        [-0.185388  , -0.241993  , -0.236478  , -0.812033  ,\n         -0.817312  ]]])tau_ability(chain, draw)float640.3091 0.261 ... 0.3925 0.3837array([[0.309088, 0.261026, 0.520055, ..., 0.542047, 0.44232 , 0.264173],\n       [0.56194 , 0.353525, 0.449636, ..., 0.254227, 0.608721, 0.416253],\n       [0.32364 , 0.264384, 0.253311, ..., 0.169554, 0.300459, 0.275523],\n       [0.376152, 0.329243, 0.302418, ..., 0.387069, 0.392527, 0.383658]])tau_day(chain, draw)float640.2309 0.2639 ... 0.9899 1.424array([[0.23094 , 0.263905, 0.402293, ..., 0.192638, 0.295471, 0.266268],\n       [0.346279, 0.369684, 0.380905, ..., 0.178461, 0.424947, 0.422784],\n       [0.541604, 0.339713, 0.156445, ..., 0.541907, 0.323856, 0.309607],\n       [0.238721, 0.239992, 0.269602, ..., 0.2551  , 0.989909, 1.4242  ]])log_lambda(chain, draw, log_lambda_dim_0)float641.672 1.672 1.672 ... 0.7911 0.7911array([[[1.67194 , 1.67194 , 1.67194 , ..., 1.03916 , 1.03916 ,\n         1.03916 ],\n        [1.54802 , 1.54802 , 1.54802 , ..., 0.936916, 0.936916,\n         0.936916],\n        [1.59076 , 1.59076 , 1.59076 , ..., 1.0784  , 1.0784  ,\n         1.0784  ],\n        ...,\n        [1.58527 , 1.58527 , 1.58527 , ..., 1.05549 , 1.05549 ,\n         1.05549 ],\n        [1.61993 , 1.61993 , 1.61993 , ..., 1.05006 , 1.05006 ,\n         1.05006 ],\n        [1.31308 , 1.31308 , 1.31308 , ..., 1.12659 , 1.12659 ,\n         1.12659 ]],\n\n       [[1.64897 , 1.64897 , 1.64897 , ..., 0.922702, 0.922702,\n         0.922702],\n        [1.70456 , 1.70456 , 1.70456 , ..., 0.848665, 0.848665,\n         0.848665],\n        [1.31055 , 1.31055 , 1.31055 , ..., 0.978268, 0.978268,\n         0.978268],\n...\n        [1.46679 , 1.46679 , 1.46679 , ..., 0.982041, 0.982041,\n         0.982041],\n        [1.55025 , 1.55025 , 1.55025 , ..., 0.791431, 0.791431,\n         0.791431],\n        [1.64212 , 1.64212 , 1.64212 , ..., 0.841571, 0.841571,\n         0.841571]],\n\n       [[1.69995 , 1.69995 , 1.69995 , ..., 1.19313 , 1.19313 ,\n         1.19313 ],\n        [1.64118 , 1.64118 , 1.64118 , ..., 0.851589, 0.851589,\n         0.851589],\n        [1.67796 , 1.67796 , 1.67796 , ..., 1.17163 , 1.17163 ,\n         1.17163 ],\n        ...,\n        [1.46774 , 1.46774 , 1.46774 , ..., 1.39109 , 1.39109 ,\n         1.39109 ],\n        [1.68949 , 1.68949 , 1.68949 , ..., 0.514135, 0.514135,\n         0.514135],\n        [1.67558 , 1.67558 , 1.67558 , ..., 0.791077, 0.791077,\n         0.791077]]])mu(chain, draw)float641.994 2.489 2.735 ... 3.746 3.653array([[1.99444, 2.48899, 2.73475, ..., 1.93786, 1.90776, 2.03307],\n       [1.90238, 2.18379, 2.30253, ..., 2.24663, 2.32451, 2.89548],\n       [2.60952, 2.49677, 2.18632, ..., 2.36378, 2.59367, 2.58251],\n       [2.50565, 2.29088, 2.54148, ..., 3.84022, 3.74587, 3.65337]])lambda(chain, draw, observation)float645.322 5.322 5.322 ... 2.206 2.206array([[[5.32246, 5.32246, 5.32246, ..., 2.82683, 2.82683, 2.82683],\n        [4.70216, 4.70216, 4.70216, ..., 2.5521 , 2.5521 , 2.5521 ],\n        [4.90749, 4.90749, 4.90749, ..., 2.93998, 2.93998, 2.93998],\n        ...,\n        [4.88061, 4.88061, 4.88061, ..., 2.87338, 2.87338, 2.87338],\n        [5.05272, 5.05272, 5.05272, ..., 2.85781, 2.85781, 2.85781],\n        [3.7176 , 3.7176 , 3.7176 , ..., 3.08512, 3.08512, 3.08512]],\n\n       [[5.20161, 5.20161, 5.20161, ..., 2.51608, 2.51608, 2.51608],\n        [5.49897, 5.49897, 5.49897, ..., 2.33653, 2.33653, 2.33653],\n        [3.70821, 3.70821, 3.70821, ..., 2.65985, 2.65985, 2.65985],\n        ...,\n        [4.40529, 4.40529, 4.40529, ..., 2.45964, 2.45964, 2.45964],\n        [5.13714, 5.13714, 5.13714, ..., 2.74474, 2.74474, 2.74474],\n        [5.41896, 5.41896, 5.41896, ..., 2.41904, 2.41904, 2.41904]],\n\n       [[3.8511 , 3.8511 , 3.8511 , ..., 3.33398, 3.33398, 3.33398],\n        [4.56912, 4.56912, 4.56912, ..., 2.42512, 2.42512, 2.42512],\n        [3.92292, 3.92292, 3.92292, ..., 2.86997, 2.86997, 2.86997],\n        ...,\n        [4.33528, 4.33528, 4.33528, ..., 2.6699 , 2.6699 , 2.6699 ],\n        [4.71266, 4.71266, 4.71266, ..., 2.20655, 2.20655, 2.20655],\n        [5.16609, 5.16609, 5.16609, ..., 2.32001, 2.32001, 2.32001]],\n\n       [[5.4737 , 5.4737 , 5.4737 , ..., 3.29737, 3.29737, 3.29737],\n        [5.16125, 5.16125, 5.16125, ..., 2.34337, 2.34337, 2.34337],\n        [5.35463, 5.35463, 5.35463, ..., 3.22724, 3.22724, 3.22724],\n        ...,\n        [4.33941, 4.33941, 4.33941, ..., 4.01922, 4.01922, 4.01922],\n        [5.41673, 5.41673, 5.41673, ..., 1.67219, 1.67219, 1.67219],\n        [5.34191, 5.34191, 5.34191, ..., 2.20577, 2.20577, 2.20577]]])Indexes: (6)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))salespersonPandasIndexPandasIndex(Index(['Morten Andersen', 'Lene Poulsen', 'Rasmus Jensen', 'Hanne Madsen',\n       'Mette Rasmussen', 'Christian Christensen', 'Helle Kristensen',\n       'Charlotte Hansen', 'Maria Petersen', 'Jette Thomsen'],\n      dtype='object', name='salesperson'))dayPandasIndexPandasIndex(Index(['Mon', 'Tue', 'Wed', 'Thu', 'Fri'], dtype='object', name='day'))log_lambda_dim_0PandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       190, 191, 192, 193, 194, 195, 196, 197, 198, 199],\n      dtype='int64', name='log_lambda_dim_0', length=200))observationPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       190, 191, 192, 193, 194, 195, 196, 197, 198, 199],\n      dtype='int64', name='observation', length=200))Attributes: (4)created_at :2024-04-12T15:48:17.803850arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  posterior_predictive\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 6MB\nDimensions:      (chain: 4, draw: 1000, observation: 200)\nCoordinates:\n  * chain        (chain) int64 32B 0 1 2 3\n  * draw         (draw) int64 8kB 0 1 2 3 4 5 6 ... 993 994 995 996 997 998 999\n  * observation  (observation) int64 2kB 0 1 2 3 4 5 ... 194 195 196 197 198 199\nData variables:\n    yrep         (chain, draw, observation) float64 6MB 2.0 5.0 8.0 ... 1.0 3.0\nAttributes:\n    created_at:                 2024-04-12T15:48:17.809481\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000observation: 200Coordinates: (3)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])observation(observation)int640 1 2 3 4 5 ... 195 196 197 198 199array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,\n        28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,\n        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,\n        56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,\n        70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,\n        84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n        98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n       112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,\n       126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n       140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\n       154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\n       168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n       182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\n       196, 197, 198, 199])Data variables: (1)yrep(chain, draw, observation)float642.0 5.0 8.0 4.0 ... 2.0 2.0 1.0 3.0array([[[ 2.,  5.,  8., ...,  1.,  1.,  3.],\n        [ 4.,  3.,  7., ...,  4.,  2.,  1.],\n        [ 6.,  5.,  6., ...,  2.,  1.,  3.],\n        ...,\n        [ 1.,  2.,  6., ...,  2.,  4.,  2.],\n        [ 4.,  4.,  1., ...,  4.,  5.,  3.],\n        [ 6.,  2.,  4., ...,  3.,  1.,  4.]],\n\n       [[ 5.,  7.,  4., ...,  2.,  2.,  2.],\n        [ 4.,  6.,  5., ...,  5.,  6.,  1.],\n        [ 1.,  4.,  6., ...,  2.,  4.,  3.],\n        ...,\n        [ 7.,  5.,  7., ...,  3.,  3.,  2.],\n        [ 1.,  3.,  6., ...,  2.,  2.,  1.],\n        [ 3.,  7.,  3., ...,  3.,  2.,  2.]],\n\n       [[ 2.,  4.,  5., ...,  5.,  4.,  2.],\n        [ 3.,  7.,  5., ...,  2.,  0.,  4.],\n        [ 4.,  0.,  3., ...,  2.,  5.,  5.],\n        ...,\n        [ 4.,  5.,  7., ...,  1.,  6.,  2.],\n        [ 5.,  3.,  0., ...,  2.,  4.,  4.],\n        [ 5.,  6.,  2., ...,  4.,  1.,  1.]],\n\n       [[11.,  2.,  5., ...,  3., 10.,  5.],\n        [ 5.,  3.,  5., ...,  0.,  2.,  0.],\n        [ 6.,  4.,  2., ...,  2.,  5.,  2.],\n        ...,\n        [ 4.,  4.,  4., ...,  2.,  6.,  4.],\n        [ 5.,  6.,  5., ...,  2.,  1.,  1.],\n        [ 8.,  4.,  1., ...,  2.,  1.,  3.]]])Indexes: (3)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))observationPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       190, 191, 192, 193, 194, 195, 196, 197, 198, 199],\n      dtype='int64', name='observation', length=200))Attributes: (4)created_at :2024-04-12T15:48:17.809481arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  log_likelihood\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 6MB\nDimensions:      (chain: 4, draw: 1000, observation: 200)\nCoordinates:\n  * chain        (chain) int64 32B 0 1 2 3\n  * draw         (draw) int64 8kB 0 1 2 3 4 5 6 ... 993 994 995 996 997 998 999\n  * observation  (observation) int64 2kB 0 1 2 3 4 5 ... 194 195 196 197 198 199\nData variables:\n    llik         (chain, draw, observation) float64 6MB -3.708 -2.098 ... -1.317\nAttributes:\n    created_at:                 2024-04-12T15:48:18.140010\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000observation: 200Coordinates: (3)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])observation(observation)int640 1 2 3 4 5 ... 195 196 197 198 199array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,\n        28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,\n        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,\n        56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,\n        70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,\n        84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n        98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n       112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,\n       126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n       140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\n       154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\n       168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n       182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\n       196, 197, 198, 199])Data variables: (1)llik(chain, draw, observation)float64-3.708 -2.098 ... -1.624 -1.317array([[[-3.70751, -2.09841, -1.81277, ..., -1.50112, -1.50112,\n         -1.44167],\n        [-4.32635, -1.84985, -1.68813, ..., -1.53311, -1.53311,\n         -1.37141],\n        [-4.10427, -1.92696, -1.72249, ..., -1.49653, -1.49653,\n         -1.47632],\n        ...,\n        [-4.13232, -1.91656, -1.71758, ..., -1.49867, -1.49867,\n         -1.45555],\n        [-3.95786, -1.9847 , -1.75107, ..., -1.4994 , -1.4994 ,\n         -1.45085],\n        [-5.69124, -1.57012, -1.64334, ..., -1.49711, -1.49711,\n         -1.52508]],\n\n       [[-3.81634, -2.04646, -1.78379, ..., -1.53973, -1.53973,\n         -1.36382],\n        [-3.55777, -2.17705, -1.85878, ..., -1.58229, -1.58229,\n         -1.33234],\n        [-5.70713, -1.56832, -1.64407, ..., -1.5168 , -1.5168 ,\n         -1.39646],\n...\n        [-4.77183, -1.72668, -1.64619, ..., -1.51554, -1.51554,\n         -1.39897],\n        [-4.31454, -1.85366, -1.6897 , ..., -1.62402, -1.62402,\n         -1.31684],\n        [-3.84934, -2.0315 , -1.77568, ..., -1.58705, -1.58705,\n         -1.33001]],\n\n       [[-3.57857, -2.16559, -1.85193, ..., -1.50975, -1.50975,\n         -1.60427],\n        [-3.85387, -2.02947, -1.77459, ..., -1.58036, -1.58036,\n         -1.33334],\n        [-3.67943, -2.1125 , -1.82084, ..., -1.50412, -1.50412,\n         -1.57713],\n        ...,\n        [-4.76644, -1.72795, -1.64651, ..., -1.63772, -1.63772,\n         -1.93019],\n        [-3.62622, -2.14001, -1.83682, ..., -1.92155, -1.92155,\n         -1.33707],\n        [-3.69049, -2.10692, -1.81763, ..., -1.6243 , -1.6243 ,\n         -1.31676]]])Indexes: (3)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))observationPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       190, 191, 192, 193, 194, 195, 196, 197, 198, 199],\n      dtype='int64', name='observation', length=200))Attributes: (4)created_at :2024-04-12T15:48:18.140010arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  sample_stats\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 204kB\nDimensions:          (chain: 4, draw: 1000)\nCoordinates:\n  * chain            (chain) int64 32B 0 1 2 3\n  * draw             (draw) int64 8kB 0 1 2 3 4 5 6 ... 994 995 996 997 998 999\nData variables:\n    lp               (chain, draw) float64 32kB 5.044 3.31 ... -8.383 -6.425\n    acceptance_rate  (chain, draw) float64 32kB 0.9985 0.8893 0.9696 ... 1.0 1.0\n    step_size        (chain, draw) float64 32kB 0.198 0.198 ... 0.2123 0.2123\n    tree_depth       (chain, draw) int64 32kB 4 4 4 4 4 4 4 4 ... 4 4 4 4 3 4 4\n    n_steps          (chain, draw) int64 32kB 31 15 15 15 15 ... 15 15 7 15 15\n    diverging        (chain, draw) bool 4kB False False False ... False False\n    energy           (chain, draw) float64 32kB 4.67 4.863 6.146 ... 15.0 18.41\nAttributes:\n    created_at:                 2024-04-12T15:48:17.807364\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000Coordinates: (2)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])Data variables: (7)lp(chain, draw)float645.044 3.31 1.622 ... -8.383 -6.425array([[ 5.04423 ,  3.30992 ,  1.62238 , ..., -5.31389 ,  1.0944  ,\n         2.31858 ],\n       [-3.60028 ,  1.65445 , -1.7666  , ..., -1.40342 ,  2.14222 ,\n        -5.20013 ],\n       [ 0.797194,  0.305094, -3.05573 , ..., -2.59559 ,  5.26241 ,\n         4.88049 ],\n       [-1.98624 ,  3.17874 ,  2.80471 , ..., -8.66517 , -8.38315 ,\n        -6.42537 ]])acceptance_rate(chain, draw)float640.9985 0.8893 0.9696 ... 1.0 1.0array([[0.998541, 0.889317, 0.969636, ..., 0.986256, 1.      , 0.984053],\n       [0.906281, 1.      , 0.918294, ..., 0.995353, 0.994652, 0.785308],\n       [0.981379, 0.962306, 0.998404, ..., 0.978206, 1.      , 0.997719],\n       [0.650137, 0.940359, 0.987465, ..., 0.878614, 1.      , 1.      ]])step_size(chain, draw)float640.198 0.198 0.198 ... 0.2123 0.2123array([[0.19804 , 0.19804 , 0.19804 , ..., 0.19804 , 0.19804 , 0.19804 ],\n       [0.193871, 0.193871, 0.193871, ..., 0.193871, 0.193871, 0.193871],\n       [0.197424, 0.197424, 0.197424, ..., 0.197424, 0.197424, 0.197424],\n       [0.212255, 0.212255, 0.212255, ..., 0.212255, 0.212255, 0.212255]])tree_depth(chain, draw)int644 4 4 4 4 4 4 4 ... 4 4 4 4 4 3 4 4array([[4, 4, 4, ..., 4, 4, 4],\n       [4, 4, 3, ..., 4, 4, 4],\n       [4, 4, 4, ..., 4, 4, 5],\n       [4, 4, 4, ..., 3, 4, 4]])n_steps(chain, draw)int6431 15 15 15 15 15 ... 15 15 7 15 15array([[31, 15, 15, ..., 15, 15, 15],\n       [31, 15, 15, ..., 15, 15, 31],\n       [15, 15, 15, ..., 31, 15, 47],\n       [15, 15, 15, ...,  7, 15, 15]])diverging(chain, draw)boolFalse False False ... False Falsearray([[False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False]])energy(chain, draw)float644.67 4.863 6.146 ... 15.0 18.41array([[ 4.67008,  4.86282,  6.14582, ..., 14.352  ,  9.50273,  5.23744],\n       [12.6651 ,  9.67118,  8.10752, ...,  6.6155 , 10.1141 , 13.0987 ],\n       [ 4.53484, 10.622  ,  7.25721, ..., 11.6512 ,  5.15128,  1.42844],\n       [ 9.58083,  8.88225,  5.18103, ..., 13.4421 , 15.0047 , 18.411  ]])Indexes: (2)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))Attributes: (4)created_at :2024-04-12T15:48:17.807364arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  prior\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 26MB\nDimensions:           (chain: 4, draw: 1000, salesperson: 10, day: 5,\n                       log_lambda_dim_0: 200, observation: 200)\nCoordinates:\n  * chain             (chain) int64 32B 0 1 2 3\n  * draw              (draw) int64 8kB 0 1 2 3 4 5 6 ... 994 995 996 997 998 999\n  * salesperson       (salesperson) object 80B 'Morten Andersen' ... 'Jette T...\n  * day               (day) object 40B 'Mon' 'Tue' 'Wed' 'Thu' 'Fri'\n  * log_lambda_dim_0  (log_lambda_dim_0) int64 2kB 0 1 2 3 4 ... 196 197 198 199\n  * observation       (observation) int64 2kB 0 1 2 3 4 ... 195 196 197 198 199\nData variables:\n    log_mu            (chain, draw) float64 32kB -0.2819 0.2299 ... 0.3186\n    ability           (chain, draw, salesperson) float64 320kB 1.697 ... -0.6347\n    day_effect        (chain, draw, day) float64 160kB 0.0977 -0.07616 ... -0.21\n    tau_ability       (chain, draw) float64 32kB 0.5064 0.8025 ... 0.3989 0.5172\n    tau_day           (chain, draw) float64 32kB 0.1327 0.2126 ... 0.2717 0.306\n    log_lambda        (chain, draw, log_lambda_dim_0) float64 6MB 1.513 ... -...\n    mu                (chain, draw) float64 32kB 0.7543 1.259 ... 2.389 1.375\n    lambda            (chain, draw, observation) float64 6MB 4.538 ... 0.591\n    yrep              (chain, draw, observation) float64 6MB 4.0 6.0 ... 0.0 1.0\n    llik              (chain, draw, observation) float64 6MB -4.517 ... -2.336\nAttributes:\n    created_at:                 2024-04-12T15:48:18.132220\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000salesperson: 10day: 5log_lambda_dim_0: 200observation: 200Coordinates: (6)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])salesperson(salesperson)object'Morten Andersen' ... 'Jette Tho...array(['Morten Andersen', 'Lene Poulsen', 'Rasmus Jensen', 'Hanne Madsen',\n       'Mette Rasmussen', 'Christian Christensen', 'Helle Kristensen',\n       'Charlotte Hansen', 'Maria Petersen', 'Jette Thomsen'], dtype=object)day(day)object'Mon' 'Tue' 'Wed' 'Thu' 'Fri'array(['Mon', 'Tue', 'Wed', 'Thu', 'Fri'], dtype=object)log_lambda_dim_0(log_lambda_dim_0)int640 1 2 3 4 5 ... 195 196 197 198 199array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,\n        28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,\n        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,\n        56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,\n        70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,\n        84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n        98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n       112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,\n       126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n       140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\n       154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\n       168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n       182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\n       196, 197, 198, 199])observation(observation)int640 1 2 3 4 5 ... 195 196 197 198 199array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,\n        28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,\n        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,\n        56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,\n        70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,\n        84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n        98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n       112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,\n       126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n       140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\n       154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\n       168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n       182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\n       196, 197, 198, 199])Data variables: (10)log_mu(chain, draw)float64-0.2819 0.2299 ... 0.8707 0.3186array([[-0.281903 ,  0.229944 ,  0.747325 , ...,  1.84674  , -1.70277  ,\n         1.37308  ],\n       [ 0.795502 , -0.303615 , -1.38647  , ...,  1.90198  ,  0.0225998,\n         0.492137 ],\n       [-0.779604 ,  1.43376  , -1.1751   , ...,  0.863031 ,  0.214353 ,\n        -0.81916  ],\n       [ 1.15465  , -0.486068 ,  0.890256 , ..., -1.0191   ,  0.870683 ,\n         0.31863  ]])ability(chain, draw, salesperson)float641.697 0.9679 ... 0.3721 -0.6347array([[[ 1.69672   ,  0.967937  ,  0.188511  , ...,  0.363965  ,\n         -0.0527054 , -0.698896  ],\n        [ 1.39934   ,  0.142625  , -0.56713   , ..., -0.168476  ,\n         -0.707109  ,  0.647036  ],\n        [ 1.33138   ,  0.0785543 , -0.594203  , ..., -0.100716  ,\n         -0.653594  ,  0.936154  ],\n        ...,\n        [ 1.43075   ,  0.765764  , -2.16614   , ...,  0.118276  ,\n         -1.66878   , -1.47486   ],\n        [-0.720742  , -0.586801  , -0.773505  , ..., -0.19011   ,\n         -0.652161  ,  1.65382   ],\n        [ 0.151401  ,  0.823675  ,  0.554763  , ...,  0.155228  ,\n          0.505573  , -0.013654  ]],\n\n       [[-0.567005  , -0.481032  , -0.406604  , ...,  0.156716  ,\n         -0.272205  , -0.510724  ],\n        [ 0.0297123 ,  0.359685  , -0.3144    , ..., -0.108956  ,\n         -0.0739124 , -0.963813  ],\n        [ 0.368609  , -0.155557  ,  0.358695  , ..., -0.340169  ,\n         -0.0291879 , -0.232412  ],\n...\n        [-0.177684  ,  0.108381  , -0.142964  , ..., -0.236728  ,\n          0.0397257 , -0.0282557 ],\n        [ 0.143016  , -0.188493  , -0.300289  , ...,  0.228774  ,\n          0.222193  ,  0.103364  ],\n        [ 0.189843  , -0.118142  , -0.32795   , ...,  0.411647  ,\n          0.344431  ,  0.241631  ]],\n\n       [[ 0.463886  ,  0.194014  , -0.069908  , ...,  0.554487  ,\n          0.311592  , -0.0516743 ],\n        [-0.475515  , -0.0802111 , -0.0406942 , ..., -0.128667  ,\n         -0.125889  ,  0.111434  ],\n        [-0.453508  , -1.5872    ,  1.83685   , ...,  0.325323  ,\n         -0.637138  ,  1.17649   ],\n        ...,\n        [ 1.08476   ,  0.719042  ,  0.1334    , ...,  0.278263  ,\n         -0.440715  , -1.16493   ],\n        [-0.721338  ,  0.195247  , -0.160349  , ...,  0.167836  ,\n         -0.0902138 ,  0.930036  ],\n        [ 0.506408  , -0.282814  , -0.00347862, ...,  0.341011  ,\n          0.372108  , -0.634673  ]]])day_effect(chain, draw, day)float640.0977 -0.07616 ... 0.00299 -0.21array([[[ 0.0976958 , -0.0761583 ,  0.183686  , -0.057312  ,\n         -0.0443529 ],\n        [ 0.0422252 , -0.00650914, -0.222078  ,  0.063902  ,\n          0.240813  ],\n        [-0.177463  , -0.0045927 ,  0.174563  , -0.0283411 ,\n          0.0458576 ],\n        ...,\n        [ 1.08014   ,  0.375844  ,  0.387076  ,  0.301333  ,\n          2.03089   ],\n        [-1.30672   , -0.266567  , -0.410274  , -0.377539  ,\n         -2.01612   ],\n        [ 0.0438633 ,  0.190006  ,  0.980988  ,  1.12222   ,\n          0.702826  ]],\n\n       [[-0.783242  , -0.092625  ,  0.176033  , -0.283157  ,\n         -0.132152  ],\n        [-0.237015  , -0.0068326 , -0.011106  ,  0.210061  ,\n          0.35143   ],\n        [ 0.0193341 ,  0.0898004 ,  0.0487427 , -0.136257  ,\n         -0.221472  ],\n...\n        [ 0.565947  ,  0.194541  , -0.2276    ,  1.04403   ,\n          0.0803301 ],\n        [ 0.731352  ,  0.0992268 ,  0.0421885 ,  0.90587   ,\n         -0.370598  ],\n        [ 0.764381  ,  0.112608  , -0.0194955 ,  0.94393   ,\n         -0.496138  ]],\n\n       [[ 0.683971  , -0.557649  ,  0.222748  , -0.180871  ,\n          0.779335  ],\n        [-0.0862852 ,  0.238294  , -0.0170358 ,  0.122428  ,\n         -0.336152  ],\n        [-0.100817  , -0.20377   ,  0.101427  ,  0.0971842 ,\n          0.287825  ],\n        ...,\n        [ 0.0560952 ,  0.00459266, -0.0967698 ,  0.00467629,\n         -0.212208  ],\n        [-0.10331   , -0.224575  ,  0.0203632 , -0.241475  ,\n          0.0857596 ],\n        [-0.216925  , -0.10625   ,  0.0714996 ,  0.00299012,\n         -0.20996   ]]])tau_ability(chain, draw)float640.5064 0.8025 ... 0.3989 0.5172array([[0.506399, 0.802482, 0.576883, ..., 0.889195, 0.801665, 0.545311],\n       [0.403014, 0.388282, 0.343047, ..., 0.113399, 0.167057, 0.301557],\n       [0.501628, 1.1735  , 0.983857, ..., 0.19434 , 0.361285, 0.262142],\n       [0.240987, 0.350018, 0.593629, ..., 0.68155 , 0.398869, 0.517181]])tau_day(chain, draw)float640.1327 0.2126 ... 0.2717 0.306array([[0.132708 , 0.212629 , 0.270336 , ..., 0.968364 , 1.14776  ,\n        1.09172  ],\n       [0.377832 , 0.30586  , 0.102613 , ..., 0.718319 , 0.375412 ,\n        0.162949 ],\n       [0.277807 , 0.288451 , 0.365592 , ..., 0.639435 , 0.377305 ,\n        0.604643 ],\n       [0.616562 , 0.201769 , 0.163502 , ..., 0.0849067, 0.271739 ,\n        0.305969 ]])log_lambda(chain, draw, log_lambda_dim_0)float641.513 1.513 1.513 ... -0.526 -0.526array([[[ 1.51251  ,  1.51251  ,  1.51251  , ..., -1.02515  ,\n         -1.02515  , -1.02515  ],\n        [ 1.67151  ,  1.67151  ,  1.67151  , ...,  1.11779  ,\n          1.11779  ,  1.11779  ],\n        [ 1.90124  ,  1.90124  ,  1.90124  , ...,  1.72934  ,\n          1.72934  ,  1.72934  ],\n        ...,\n        [ 4.35763  ,  4.35763  ,  4.35763  , ...,  2.40277  ,\n          2.40277  ,  2.40277  ],\n        [-3.73023  , -3.73023  , -3.73023  , ..., -2.06507  ,\n         -2.06507  , -2.06507  ],\n        [ 1.56834  ,  1.56834  ,  1.56834  , ...,  2.06225  ,\n          2.06225  ,  2.06225  ]],\n\n       [[-0.554744 , -0.554744 , -0.554744 , ...,  0.152626 ,\n          0.152626 ,  0.152626 ],\n        [-0.510917 , -0.510917 , -0.510917 , ..., -0.915998 ,\n         -0.915998 , -0.915998 ],\n        [-0.998522 , -0.998522 , -0.998522 , ..., -1.84035  ,\n         -1.84035  , -1.84035  ],\n...\n        [ 1.25129  ,  1.25129  ,  1.25129  , ...,  0.915105 ,\n          0.915105 ,  0.915105 ],\n        [ 1.08872  ,  1.08872  ,  1.08872  , ..., -0.0528814,\n         -0.0528814, -0.0528814],\n        [ 0.135065 ,  0.135065 ,  0.135065 , ..., -1.07367  ,\n         -1.07367  , -1.07367  ]],\n\n       [[ 2.30251  ,  2.30251  ,  2.30251  , ...,  1.88231  ,\n          1.88231  ,  1.88231  ],\n        [-1.04787  , -1.04787  , -1.04787  , ..., -0.710786 ,\n         -0.710786 , -0.710786 ],\n        [ 0.335932 ,  0.335932 ,  0.335932 , ...,  2.35458  ,\n          2.35458  ,  2.35458  ],\n        ...,\n        [ 0.121754 ,  0.121754 ,  0.121754 , ..., -2.39623  ,\n         -2.39623  , -2.39623  ],\n        [ 0.0460353,  0.0460353,  0.0460353, ...,  1.88648  ,\n          1.88648  ,  1.88648  ],\n        [ 0.608114 ,  0.608114 ,  0.608114 , ..., -0.526002 ,\n         -0.526002 , -0.526002 ]]])mu(chain, draw)float640.7543 1.259 2.111 ... 2.389 1.375array([[0.754347, 1.25853 , 2.11134 , ..., 6.33912 , 0.182178, 3.94748 ],\n       [2.21555 , 0.738145, 0.249957, ..., 6.69914 , 1.02286 , 1.63581 ],\n       [0.458588, 4.19445 , 0.308789, ..., 2.37033 , 1.23906 , 0.440802],\n       [3.17292 , 0.61504 , 2.43575 , ..., 0.36092 , 2.38854 , 1.37524 ]])lambda(chain, draw, observation)float644.538 4.538 4.538 ... 0.591 0.591array([[[4.53812e+00, 4.53812e+00, 4.53812e+00, ..., 3.58742e-01,\n         3.58742e-01, 3.58742e-01],\n        [5.32017e+00, 5.32017e+00, 5.32017e+00, ..., 3.05810e+00,\n         3.05810e+00, 3.05810e+00],\n        [6.69421e+00, 6.69421e+00, 6.69421e+00, ..., 5.63691e+00,\n         5.63691e+00, 5.63691e+00],\n        ...,\n        [7.80722e+01, 7.80722e+01, 7.80722e+01, ..., 1.10537e+01,\n         1.10537e+01, 1.10537e+01],\n        [2.39872e-02, 2.39872e-02, 2.39872e-02, ..., 1.26809e-01,\n         1.26809e-01, 1.26809e-01],\n        [4.79869e+00, 4.79869e+00, 4.79869e+00, ..., 7.86365e+00,\n         7.86365e+00, 7.86365e+00]],\n\n       [[5.74219e-01, 5.74219e-01, 5.74219e-01, ..., 1.16489e+00,\n         1.16489e+00, 1.16489e+00],\n        [5.99945e-01, 5.99945e-01, 5.99945e-01, ..., 4.00117e-01,\n         4.00117e-01, 4.00117e-01],\n        [3.68424e-01, 3.68424e-01, 3.68424e-01, ..., 1.58762e-01,\n         1.58762e-01, 1.58762e-01],\n...\n        [3.49486e+00, 3.49486e+00, 3.49486e+00, ..., 2.49704e+00,\n         2.49704e+00, 2.49704e+00],\n        [2.97047e+00, 2.97047e+00, 2.97047e+00, ..., 9.48493e-01,\n         9.48493e-01, 9.48493e-01],\n        [1.14461e+00, 1.14461e+00, 1.14461e+00, ..., 3.41753e-01,\n         3.41753e-01, 3.41753e-01]],\n\n       [[9.99923e+00, 9.99923e+00, 9.99923e+00, ..., 6.56867e+00,\n         6.56867e+00, 6.56867e+00],\n        [3.50685e-01, 3.50685e-01, 3.50685e-01, ..., 4.91258e-01,\n         4.91258e-01, 4.91258e-01],\n        [1.39924e+00, 1.39924e+00, 1.39924e+00, ..., 1.05337e+01,\n         1.05337e+01, 1.05337e+01],\n        ...,\n        [1.12948e+00, 1.12948e+00, 1.12948e+00, ..., 9.10603e-02,\n         9.10603e-02, 9.10603e-02],\n        [1.04711e+00, 1.04711e+00, 1.04711e+00, ..., 6.59610e+00,\n         6.59610e+00, 6.59610e+00],\n        [1.83696e+00, 1.83696e+00, 1.83696e+00, ..., 5.90963e-01,\n         5.90963e-01, 5.90963e-01]]])yrep(chain, draw, observation)float644.0 6.0 3.0 1.0 ... 1.0 0.0 0.0 1.0array([[[ 4.,  6.,  3., ...,  0.,  0.,  0.],\n        [ 6.,  1., 12., ...,  5.,  4.,  5.],\n        [ 4.,  3.,  2., ...,  4., 10.,  5.],\n        ...,\n        [70., 88., 72., ..., 10.,  8., 11.],\n        [ 0.,  0.,  0., ...,  0.,  2.,  0.],\n        [ 7.,  8.,  4., ...,  7.,  7., 12.]],\n\n       [[ 0.,  2.,  1., ...,  1.,  2.,  1.],\n        [ 1.,  2.,  0., ...,  0.,  0.,  0.],\n        [ 0.,  0.,  0., ...,  0.,  1.,  0.],\n        ...,\n        [10.,  7.,  3., ..., 14., 12., 11.],\n        [ 0.,  4.,  0., ...,  1.,  0.,  2.],\n        [ 2.,  4.,  2., ...,  3.,  0.,  2.]],\n\n       [[ 1.,  0.,  0., ...,  1.,  0.,  0.],\n        [ 2.,  7.,  3., ...,  0.,  2.,  1.],\n        [ 0.,  0.,  1., ...,  1.,  0.,  2.],\n        ...,\n        [ 4.,  2.,  6., ...,  3.,  4.,  4.],\n        [ 3.,  1.,  2., ...,  2.,  1.,  1.],\n        [ 0.,  1.,  0., ...,  0.,  0.,  0.]],\n\n       [[13., 12., 11., ...,  6.,  7.,  4.],\n        [ 0.,  0.,  1., ...,  0.,  0.,  1.],\n        [ 3.,  2.,  1., ...,  9., 11.,  6.],\n        ...,\n        [ 0.,  0.,  2., ...,  0.,  0.,  0.],\n        [ 0.,  1.,  0., ...,  7.,  5.,  6.],\n        [ 0.,  2.,  1., ...,  0.,  0.,  1.]]])llik(chain, draw, observation)float64-4.517 -1.792 ... -3.961 -2.336array([[[ -4.5174 ,  -1.79234,  -1.66612, ...,  -5.22596,  -5.22596,\n          -3.10219],\n        [ -3.70953,  -2.09741,  -1.8122 , ...,  -1.49648,  -1.49648,\n          -1.51566],\n        [ -2.78619,  -2.78224,  -2.26729, ...,  -2.24066,  -2.24066,\n          -2.87139],\n        ...,\n        [-49.6003 , -66.7911 , -63.8197 , ...,  -5.63717,  -5.63717,\n          -6.94132],\n        [-52.4307 , -13.0064 , -18.123  , ...,  -8.11378,  -8.11378,\n          -4.9501 ],\n        [ -4.21968,  -1.88542,  -1.70337, ...,  -3.46866,  -3.46866,\n          -4.43229]],\n\n       [[-21.2261 ,  -4.03021,  -5.97125, ...,  -2.49877,  -2.49877,\n          -1.55278],\n        [-20.8135 ,  -3.92446,  -5.82167, ...,  -4.93987,  -4.93987,\n          -2.92526],\n        [-25.4581 ,  -5.15575,  -7.54056, ...,  -7.47157,  -7.47157,\n          -4.53261],\n...\n        [ -6.08634,  -1.53274,  -1.66774, ...,  -1.54348,  -1.54348,\n          -1.35997],\n        [ -7.18767,  -1.49607,  -1.79364, ...,  -2.8989 ,  -2.8989 ,\n          -1.7474 ],\n        [-14.8984 ,  -2.53118,  -3.78241, ...,  -5.35451,  -5.35451,\n          -3.18223]],\n\n       [[ -2.07856,  -4.88347,  -3.96725, ...,  -2.7135 ,  -2.7135 ,\n          -3.49719],\n        [-25.9338 ,  -5.28605,  -7.72021, ...,  -4.41538,  -4.41538,\n          -2.60598],\n        [-13.1443 ,  -2.18321,  -3.23357, ...,  -5.26169,  -5.26169,\n          -6.51765],\n        ...,\n        [-15.0164 ,  -2.55597,  -3.82051, ...,  -9.07152,  -9.07152,\n          -5.57667],\n        [-15.6912 ,  -2.70077,  -4.04102, ...,  -2.72843,  -2.72843,\n          -3.51629],\n        [-10.8602 ,  -1.80438,  -2.58256, ...,  -3.96073,  -3.96073,\n          -2.33611]]])Indexes: (6)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))salespersonPandasIndexPandasIndex(Index(['Morten Andersen', 'Lene Poulsen', 'Rasmus Jensen', 'Hanne Madsen',\n       'Mette Rasmussen', 'Christian Christensen', 'Helle Kristensen',\n       'Charlotte Hansen', 'Maria Petersen', 'Jette Thomsen'],\n      dtype='object', name='salesperson'))dayPandasIndexPandasIndex(Index(['Mon', 'Tue', 'Wed', 'Thu', 'Fri'], dtype='object', name='day'))log_lambda_dim_0PandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       190, 191, 192, 193, 194, 195, 196, 197, 198, 199],\n      dtype='int64', name='log_lambda_dim_0', length=200))observationPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       190, 191, 192, 193, 194, 195, 196, 197, 198, 199],\n      dtype='int64', name='observation', length=200))Attributes: (4)created_at :2024-04-12T15:48:18.132220arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  sample_stats_prior\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 204kB\nDimensions:          (chain: 4, draw: 1000)\nCoordinates:\n  * chain            (chain) int64 32B 0 1 2 3\n  * draw             (draw) int64 8kB 0 1 2 3 4 5 6 ... 994 995 996 997 998 999\nData variables:\n    lp               (chain, draw) float64 32kB 2.062 2.112 ... 6.253 6.118\n    acceptance_rate  (chain, draw) float64 32kB 0.4033 0.987 ... 0.8181 0.9423\n    step_size        (chain, draw) float64 32kB 0.1347 0.1347 ... 0.1899 0.1899\n    tree_depth       (chain, draw) int64 32kB 5 6 5 5 5 5 6 6 ... 4 5 5 5 5 4 4\n    n_steps          (chain, draw) int64 32kB 31 63 31 31 63 ... 31 31 31 15 15\n    diverging        (chain, draw) bool 4kB False False False ... False False\n    energy           (chain, draw) float64 32kB 5.961 5.001 12.0 ... 2.364 2.745\nAttributes:\n    created_at:                 2024-04-12T15:48:18.135915\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000Coordinates: (2)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])Data variables: (7)lp(chain, draw)float642.062 2.112 1.498 ... 6.253 6.118array([[  2.06183 ,   2.11181 ,   1.49755 , ..., -18.769   , -12.7581  ,\n         -3.75847 ],\n       [  0.192078,   5.4497  ,   8.75415 , ...,  13.6004  ,  15.0021  ,\n         11.9102  ],\n       [ -3.9913  ,  -6.78302 ,  -4.7958  , ...,   8.04658 ,   5.20399 ,\n          4.04715 ],\n       [  2.06794 ,   8.94946 ,  -3.79256 , ...,   3.04474 ,   6.25327 ,\n          6.11812 ]])acceptance_rate(chain, draw)float640.4033 0.987 ... 0.8181 0.9423array([[0.403268 , 0.987006 , 0.85906  , ..., 0.99483  , 0.99969  ,\n        0.941612 ],\n       [0.973169 , 0.997546 , 0.922656 , ..., 0.894845 , 0.41768  ,\n        0.718917 ],\n       [0.75833  , 0.998893 , 0.994761 , ..., 0.75279  , 0.539659 ,\n        0.954256 ],\n       [0.964808 , 0.992126 , 0.805935 , ..., 0.0970982, 0.81811  ,\n        0.9423   ]])step_size(chain, draw)float640.1347 0.1347 ... 0.1899 0.1899array([[0.134654, 0.134654, 0.134654, ..., 0.134654, 0.134654, 0.134654],\n       [0.183312, 0.183312, 0.183312, ..., 0.183312, 0.183312, 0.183312],\n       [0.199388, 0.199388, 0.199388, ..., 0.199388, 0.199388, 0.199388],\n       [0.189886, 0.189886, 0.189886, ..., 0.189886, 0.189886, 0.189886]])tree_depth(chain, draw)int645 6 5 5 5 5 6 6 ... 4 4 5 5 5 5 4 4array([[5, 6, 5, ..., 5, 6, 6],\n       [5, 4, 4, ..., 4, 4, 4],\n       [5, 5, 5, ..., 4, 3, 3],\n       [4, 4, 4, ..., 5, 4, 4]])n_steps(chain, draw)int6431 63 31 31 63 ... 31 31 31 15 15array([[31, 63, 31, ..., 31, 63, 63],\n       [31, 15, 31, ..., 15, 23, 15],\n       [31, 31, 31, ..., 15,  7, 15],\n       [15, 15, 15, ..., 31, 15, 15]])diverging(chain, draw)boolFalse False False ... False Falsearray([[False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False]])energy(chain, draw)float645.961 5.001 12.0 ... 2.364 2.745array([[ 5.96111,  5.00131, 11.9994 , ..., 26.0043 , 26.9278 , 23.612  ],\n       [ 8.58193,  4.11187,  9.96714, ..., -4.82565, -3.25164, -2.56362],\n       [18.1651 , 18.7183 , 14.7327 , ..., -2.759  ,  3.53789,  1.03064],\n       [ 6.68649,  3.08615,  8.64779, ...,  7.1652 ,  2.36438,  2.74493]])Indexes: (2)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))Attributes: (4)created_at :2024-04-12T15:48:18.135915arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  observed_data\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 10kB\nDimensions:              (N_dim_0: 1, N_salesperson_dim_0: 1, N_day_dim_0: 1,\n                          salesperson_dim_0: 200, day_dim_0: 200,\n                          sales_dim_0: 200, likelihood_dim_0: 1)\nCoordinates:\n  * N_dim_0              (N_dim_0) int64 8B 0\n  * N_salesperson_dim_0  (N_salesperson_dim_0) int64 8B 0\n  * N_day_dim_0          (N_day_dim_0) int64 8B 0\n  * salesperson_dim_0    (salesperson_dim_0) int64 2kB 0 1 2 3 ... 197 198 199\n  * day_dim_0            (day_dim_0) int64 2kB 0 1 2 3 4 ... 195 196 197 198 199\n  * sales_dim_0          (sales_dim_0) int64 2kB 0 1 2 3 4 ... 196 197 198 199\n  * likelihood_dim_0     (likelihood_dim_0) int64 8B 0\nData variables:\n    N                    (N_dim_0) int64 8B 200\n    N_salesperson        (N_salesperson_dim_0) int64 8B 10\n    N_day                (N_day_dim_0) int64 8B 5\n    salesperson          (salesperson_dim_0) int64 2kB 1 1 1 1 2 ... 10 10 10 10\n    day                  (day_dim_0) int64 2kB 1 1 1 1 1 1 1 1 ... 5 5 5 5 5 5 5\n    sales                (sales_dim_0) int64 2kB 10 3 4 4 4 5 6 ... 4 1 1 3 3 2\n    likelihood           (likelihood_dim_0) int64 8B 1\nAttributes:\n    created_at:                 2024-04-12T15:48:18.138276\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:N_dim_0: 1N_salesperson_dim_0: 1N_day_dim_0: 1salesperson_dim_0: 200day_dim_0: 200sales_dim_0: 200likelihood_dim_0: 1Coordinates: (7)N_dim_0(N_dim_0)int640array([0])N_salesperson_dim_0(N_salesperson_dim_0)int640array([0])N_day_dim_0(N_day_dim_0)int640array([0])salesperson_dim_0(salesperson_dim_0)int640 1 2 3 4 5 ... 195 196 197 198 199array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,\n        28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,\n        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,\n        56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,\n        70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,\n        84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n        98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n       112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,\n       126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n       140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\n       154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\n       168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n       182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\n       196, 197, 198, 199])day_dim_0(day_dim_0)int640 1 2 3 4 5 ... 195 196 197 198 199array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,\n        28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,\n        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,\n        56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,\n        70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,\n        84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n        98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n       112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,\n       126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n       140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\n       154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\n       168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n       182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\n       196, 197, 198, 199])sales_dim_0(sales_dim_0)int640 1 2 3 4 5 ... 195 196 197 198 199array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,\n        28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,\n        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,\n        56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,\n        70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,\n        84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\n        98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n       112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,\n       126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n       140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,\n       154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\n       168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n       182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\n       196, 197, 198, 199])likelihood_dim_0(likelihood_dim_0)int640array([0])Data variables: (7)N(N_dim_0)int64200array([200])N_salesperson(N_salesperson_dim_0)int6410array([10])N_day(N_day_dim_0)int645array([5])salesperson(salesperson_dim_0)int641 1 1 1 2 2 2 ... 9 9 9 10 10 10 10array([ 1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  4,  4,  4,  4,  5,\n        5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9,\n        9,  9, 10, 10, 10, 10,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,\n        3,  4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,\n        8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10,  1,  1,  1,  1,  2,\n        2,  2,  2,  3,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,  5,  6,  6,\n        6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10,\n       10,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  4,  4,  4,  4,\n        5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,\n        9,  9,  9, 10, 10, 10, 10,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,\n        3,  3,  4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,\n        7,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10])day(day_dim_0)int641 1 1 1 1 1 1 1 ... 5 5 5 5 5 5 5 5array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,\n       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,\n       3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n       3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n       4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n       4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n       5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n       5, 5])sales(sales_dim_0)int6410 3 4 4 4 5 6 4 ... 2 4 1 1 3 3 2array([10,  3,  4,  4,  4,  5,  6,  4,  2,  4,  0,  4,  3,  3,  4,  4,  0,\n        1,  2,  1,  2,  2,  5,  6,  4,  1,  5,  3,  5,  1,  7,  0,  1,  1,\n        2,  3,  8,  6,  3,  4,  1,  3,  4,  8,  5,  8,  4,  1,  2,  0,  3,\n        1,  5,  3,  2,  3,  0,  3,  2,  0,  2,  1,  3,  2,  3,  4,  5,  3,\n        1,  1,  1,  3,  3,  1,  1,  1,  4,  4,  3,  4,  4,  3,  5,  4,  2,\n        2,  5,  4,  3,  3,  1,  2,  3,  2,  2,  2,  0,  1,  4,  1,  3,  2,\n        1,  2,  4,  4,  3,  4,  2,  1,  1,  2,  4,  1,  3,  2,  4,  3,  6,\n        4,  1,  4,  4,  0,  0,  5,  2,  3,  2,  0,  2,  1,  3,  3,  2,  3,\n        1,  1,  1,  1,  2,  2,  0,  1,  1,  3,  0,  3,  0,  1,  0,  0,  1,\n        0,  1,  1,  4,  3,  3,  1,  3,  2,  6,  2,  2,  3,  2,  3,  0,  2,\n        2,  4,  2,  2,  1,  0,  0,  2,  2,  0,  1,  2,  0,  1,  3,  3,  1,\n        0,  3,  2,  2,  0,  3,  2,  4,  1,  1,  3,  3,  2])likelihood(likelihood_dim_0)int641array([1])Indexes: (7)N_dim_0PandasIndexPandasIndex(Index([0], dtype='int64', name='N_dim_0'))N_salesperson_dim_0PandasIndexPandasIndex(Index([0], dtype='int64', name='N_salesperson_dim_0'))N_day_dim_0PandasIndexPandasIndex(Index([0], dtype='int64', name='N_day_dim_0'))salesperson_dim_0PandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       190, 191, 192, 193, 194, 195, 196, 197, 198, 199],\n      dtype='int64', name='salesperson_dim_0', length=200))day_dim_0PandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       190, 191, 192, 193, 194, 195, 196, 197, 198, 199],\n      dtype='int64', name='day_dim_0', length=200))sales_dim_0PandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       190, 191, 192, 193, 194, 195, 196, 197, 198, 199],\n      dtype='int64', name='sales_dim_0', length=200))likelihood_dim_0PandasIndexPandasIndex(Index([0], dtype='int64', name='likelihood_dim_0'))Attributes: (4)created_at :2024-04-12T15:48:18.138276arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n              \n            \n            \n\n\n\naz.summary(idata, var_names=\"~lambda\", filter_vars=\"regex\")\n\n\n\n\n\n\n\n\n\nmean\nsd\nhdi_3%\nhdi_97%\nmcse_mean\nmcse_sd\ness_bulk\ness_tail\nr_hat\n\n\n\n\nlog_mu\n0.777\n0.211\n0.386\n1.181\n0.009\n0.006\n599.0\n840.0\n1.01\n\n\nability[Morten Andersen]\n0.441\n0.176\n0.124\n0.781\n0.006\n0.004\n973.0\n1193.0\n1.00\n\n\nability[Lene Poulsen]\n0.374\n0.176\n0.035\n0.691\n0.006\n0.004\n1005.0\n1265.0\n1.00\n\n\nability[Rasmus Jensen]\n-0.164\n0.186\n-0.507\n0.188\n0.005\n0.004\n1272.0\n1693.0\n1.00\n\n\nability[Hanne Madsen]\n0.103\n0.180\n-0.242\n0.445\n0.005\n0.004\n1151.0\n1165.0\n1.00\n\n\nability[Mette Rasmussen]\n-0.539\n0.213\n-0.927\n-0.136\n0.005\n0.004\n1643.0\n1884.0\n1.00\n\n\nability[Christian Christensen]\n-0.123\n0.187\n-0.513\n0.205\n0.005\n0.004\n1239.0\n1828.0\n1.00\n\n\nability[Helle Kristensen]\n0.187\n0.180\n-0.168\n0.516\n0.005\n0.004\n1187.0\n1474.0\n1.00\n\n\nability[Charlotte Hansen]\n-0.273\n0.195\n-0.635\n0.089\n0.005\n0.004\n1310.0\n1513.0\n1.00\n\n\nability[Maria Petersen]\n-0.211\n0.189\n-0.576\n0.127\n0.005\n0.004\n1335.0\n1465.0\n1.00\n\n\nability[Jette Thomsen]\n0.416\n0.178\n0.090\n0.755\n0.005\n0.004\n1117.0\n806.0\n1.00\n\n\nday_effect[Mon]\n0.341\n0.184\n0.005\n0.692\n0.007\n0.006\n868.0\n943.0\n1.00\n\n\nday_effect[Tue]\n0.120\n0.184\n-0.216\n0.457\n0.006\n0.005\n965.0\n1083.0\n1.00\n\n\nday_effect[Wed]\n0.131\n0.183\n-0.196\n0.485\n0.006\n0.005\n971.0\n887.0\n1.00\n\n\nday_effect[Thu]\n-0.303\n0.192\n-0.671\n0.045\n0.006\n0.004\n1041.0\n1038.0\n1.00\n\n\nday_effect[Fri]\n-0.175\n0.187\n-0.516\n0.188\n0.006\n0.005\n911.0\n1128.0\n1.00\n\n\ntau_ability\n0.397\n0.120\n0.203\n0.619\n0.003\n0.002\n1853.0\n2200.0\n1.00\n\n\ntau_day\n0.346\n0.148\n0.122\n0.625\n0.004\n0.003\n1765.0\n2045.0\n1.00\n\n\nmu\n2.223\n0.473\n1.315\n3.035\n0.019\n0.013\n599.0\n840.0\n1.01",
    "crumbs": [
      "Course materials",
      "Hierarchical models"
    ]
  },
  {
    "objectID": "hierarchical_models.html#the-problem-with-hierarchical-models-funnels",
    "href": "hierarchical_models.html#the-problem-with-hierarchical-models-funnels",
    "title": "Hierarchical models",
    "section": "The problem with hierarchical models: funnels",
    "text": "The problem with hierarchical models: funnels\nDid you notice that cmdstanpy printed some divergent transition warnings above? This illustrates a pervasive problem with hierarchical models: funnel-shaped marginal posterior distributions. The plot below shows the values of the parameter \\(\\tau_{day}\\) and the corresponding day effect values for Monday in the prior samples:\n\naz.plot_pair(\n    idata.prior,\n    var_names=[\"tau_day\", \"day_effect\"],\n    coords={\"day\": [\"Mon\"]},\n);\n\n/Users/tedgro/repos/biosustain/bayesian_statistics_for_computational_biology/.venv/lib/python3.12/site-packages/arviz/plots/pairplot.py:232: FutureWarning: The return type of `Dataset.dims` will be changed to return a set of dimension names in future, in order to be more consistent with `DataArray.dims`. To access a mapping from dimension names to lengths, please use `Dataset.sizes`.\n  gridsize = int(dataset.dims[\"draw\"] ** 0.35)\n\n\n\n\n\n\n\n\n\nAs we discussed previously, funnels are hard to sample because of their inconsistent characteristic lengths. Unfortunately, they are often inevitable in hierarchical models. Do you get an idea why from the graph?\nThere are three main solutions to funnels: add more information, tune the HMC algorithm or reparameterise the model.\n\nAdd more information\nThe posterior distribution didn’t have any divergent transitions. This is probably because the extra information in the measurements made it easier to sample. Comparing the marginal distributions from above illustrates how this can happen: note that the difference in scale between the neck and the bowl of the funnel is less extreme for the posterior samples.\n\nfrom matplotlib import pyplot as plt\nf, ax = plt.subplots()\naz.plot_pair(\n    idata.prior,\n    var_names=[\"tau_day\", \"day_effect\"],\n    coords={\"day\": [\"Mon\"]},\n    ax=ax,\n    scatter_kwargs={\"label\": \"prior\"},\n);\naz.plot_pair(\n    idata.posterior,\n    var_names=[\"tau_day\", \"day_effect\"],\n    coords={\"day\": [\"Mon\"]},\n    ax=ax,\n    scatter_kwargs={\"label\": \"posterior\"},\n);\nax.legend(frameon=False);\n\n/Users/tedgro/repos/biosustain/bayesian_statistics_for_computational_biology/.venv/lib/python3.12/site-packages/arviz/plots/pairplot.py:232: FutureWarning: The return type of `Dataset.dims` will be changed to return a set of dimension names in future, in order to be more consistent with `DataArray.dims`. To access a mapping from dimension names to lengths, please use `Dataset.sizes`.\n  gridsize = int(dataset.dims[\"draw\"] ** 0.35)\n/Users/tedgro/repos/biosustain/bayesian_statistics_for_computational_biology/.venv/lib/python3.12/site-packages/arviz/plots/pairplot.py:232: FutureWarning: The return type of `Dataset.dims` will be changed to return a set of dimension names in future, in order to be more consistent with `DataArray.dims`. To access a mapping from dimension names to lengths, please use `Dataset.sizes`.\n  gridsize = int(dataset.dims[\"draw\"] ** 0.35)\n\n\n\n\n\n\n\n\n\nIf better measurements aren’t available, divergences can often be avoided by searching for extra information that can justify narrower priors.\n\n\nTune the algorithm\nStan allows increasing the length of the warmup phase (iter_warmup, default 2000), bringing the target acceptance probability close to 1 (adapt_delta, default 0.8) and by increasing the leapfrog integrator’s maximum tree depth (max_treedepth, default 10). All of these changes trade speed for reliability.\n\nmcmc_prior_2 = model.sample(\n    data=data_prior,\n    iter_warmup=3000,\n    adapt_delta=0.99,\n    max_treedepth=12\n)\n\n17:48:18 - cmdstanpy - INFO - CmdStan start processing\n17:48:47 - cmdstanpy - INFO - CmdStan done processing.\n17:48:47 - cmdstanpy - WARNING - Some chains may have failed to converge.\n    Chain 3 had 998 iterations at max treedepth (99.8%)\n    Use the \"diagnose()\" method on the CmdStanMCMC object to see further information.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                                                                                                                                                                                                                                                                                \n\n\nUnfortunately even quite aggressive tuning doesn’t get rid of all the divergent transitions in this case.\n\n\nReparameterise\nThe idea with reparameterisation is to define auxiliary parameters which don’t have problematic relationships, then recover the problematic parameters later.\n“Non-centred” parameterisations take a distribution with the form \\(\\alpha\\sim\nD(\\mu,\\sigma)\\) and express it as follows:\n\\[\\begin{align*}\nu \\sim D(0, 1)\\\\\n\\alpha = \\mu + u * \\sigma\n\\end{align*}\\]\n\nmodel_nc = CmdStanModel(stan_file=\"../src/stan/plushies-nc.stan\")\nprint(model_nc.code())\n\ndata {\n int&lt;lower=1&gt; N;\n int&lt;lower=1&gt; N_salesperson;\n int&lt;lower=1&gt; N_day;\n array[N] int&lt;lower=1,upper=N_salesperson&gt; salesperson;\n array[N] int&lt;lower=1,upper=N_day&gt; day;\n array[N] int&lt;lower=0&gt; sales;\n int&lt;lower=0,upper=1&gt; likelihood;\n}\nparameters {\n real log_mu;\n vector[N_salesperson] ability_z;\n vector[N_day] day_effect_z;\n real&lt;lower=0&gt; tau_ability;\n real&lt;lower=0&gt; tau_day;\n}\ntransformed parameters {\n vector[N_salesperson] ability = ability_z * tau_ability;\n vector[N_day] day_effect = day_effect_z * tau_day;\n vector[N] log_lambda = log_mu + ability[salesperson] + day_effect[day]; \n}\nmodel {\n  log_mu ~ normal(0, 1);\n  ability_z ~ normal(0, 1);\n  day_effect_z ~ normal(0, 1);\n  tau_ability ~ normal(0, 1);\n  tau_day ~ normal(0, 1);\n  if (likelihood){\n    sales ~ poisson_log(log_lambda);\n  }\n}\ngenerated quantities {\n real mu = exp(log_mu);\n vector[N] lambda = exp(log_lambda);\n array[N] int yrep = poisson_rng(lambda);\n vector[N] llik; \n for (n in 1:N){\n   llik[n] = poisson_lpmf(sales[n] | lambda[n]);\n }\n}\n\n\n\n\nmcmc_prior_nc = model.sample(\n    data=data_prior,\n    iter_warmup=3000,\n    adapt_delta=0.999,\n    max_treedepth=12\n)\n\n17:48:47 - cmdstanpy - INFO - CmdStan start processing\n17:48:57 - cmdstanpy - INFO - CmdStan done processing.\n17:48:57 - cmdstanpy - WARNING - Non-fatal error during sampling:\nException: normal_lpdf: Scale parameter is 0, but must be positive! (in 'plushies.stan', line 23, column 2 to column 34)\nConsider re-running with show_console=True if the above output is unclear!\n17:48:57 - cmdstanpy - WARNING - Some chains may have failed to converge.\n    Chain 1 had 3 divergent transitions (0.3%)\n    Use the \"diagnose()\" method on the CmdStanMCMC object to see further information.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                                                                                                                                                                                                                                                                                \n\n\nBeware of using non-centred parameterisation as a default: it isn’t guaranteed to be better.",
    "crumbs": [
      "Course materials",
      "Hierarchical models"
    ]
  },
  {
    "objectID": "hierarchical_models.html#so-how-many-plushies-do-i-need-to-sell",
    "href": "hierarchical_models.html#so-how-many-plushies-do-i-need-to-sell",
    "title": "Hierarchical models",
    "section": "So how many plushies do I need to sell?",
    "text": "So how many plushies do I need to sell?\n\nf, ax = plt.subplots()\naz.plot_forest(\n    np.exp(idata.posterior[\"log_mu\"] + idata.posterior[\"ability\"]),\n    kind=\"forestplot\",\n    combined=True,\n    ax=ax,\n    show=False,\n);\nax.scatter(\n    np.exp(np.log(BASELINE) + salespeople[\"ability\"]), \n    ax.get_yticks()[::-1], \n    color=\"red\", \n    label=\"True expected sales\",\n    zorder=2\n)\nax.scatter(\n    sales.groupby(\"salesperson\")[\"sales\"].mean().reindex(salespeople[\"salesperson\"]), \n    ax.get_yticks()[::-1], \n    color=\"black\", \n    label=\"Observed sales per day\",\n    zorder=3\n)\nax.set(title=\"\", xlabel=\"Number of plushies sold per day\")\nax.axvline(BASELINE, linestyle=\"--\", label=\"baseline\", linewidth=0.8, color=\"black\")\nax.legend(frameon=False);",
    "crumbs": [
      "Course materials",
      "Hierarchical models"
    ]
  },
  {
    "objectID": "hierarchical_models.html#takeaways",
    "href": "hierarchical_models.html#takeaways",
    "title": "Hierarchical models",
    "section": "Takeaways",
    "text": "Takeaways\n\nHierarchical models are a powerful way to capture structural information\nYou may run into problematic sampling, but you have options!\nThere is surprisingly little information in low-expected-value count data.",
    "crumbs": [
      "Course materials",
      "Hierarchical models"
    ]
  },
  {
    "objectID": "metropolis-hastings.html",
    "href": "metropolis-hastings.html",
    "title": "Metropolis Hastings",
    "section": "",
    "text": "Welcome back!\nPlan for today:\n\nMarkov Chains\nMetropolis-Hastings explained\n\nRecap from last week:\nWhat is MCMC trying to solve: MCMC",
    "crumbs": [
      "Course materials",
      "Metropolis Hastings"
    ]
  },
  {
    "objectID": "metropolis-hastings.html#introduction",
    "href": "metropolis-hastings.html#introduction",
    "title": "Metropolis Hastings",
    "section": "",
    "text": "Welcome back!\nPlan for today:\n\nMarkov Chains\nMetropolis-Hastings explained\n\nRecap from last week:\nWhat is MCMC trying to solve: MCMC",
    "crumbs": [
      "Course materials",
      "Metropolis Hastings"
    ]
  },
  {
    "objectID": "metropolis-hastings.html#mcmc",
    "href": "metropolis-hastings.html#mcmc",
    "title": "Metropolis Hastings",
    "section": "MCMC",
    "text": "MCMC",
    "crumbs": [
      "Course materials",
      "Metropolis Hastings"
    ]
  },
  {
    "objectID": "metropolis-hastings.html#markov-chains",
    "href": "metropolis-hastings.html#markov-chains",
    "title": "Metropolis Hastings",
    "section": "Markov Chains",
    "text": "Markov Chains\nA Markov Chain is any process that is memoryless such that\n\\[ p(x^{i} | x^{i-1},...,x^{1}) = p(x^{i} | x^{i-1}). \\]\nFor example:\n\nThe transitions can be measured as discrete time steps with the following matrix representation\n\nimport numpy as np\nT = np.matrix([[0.1, 0.1, 0.8], [0.5, 0.1, 0.4], [0.5, 0.2, 0.3]])\nprint(T)\n\n[[0.1 0.1 0.8]\n [0.5 0.1 0.4]\n [0.5 0.2 0.3]]\n\n\nGiven an initial starting position\n\nv0 = np.matrix([0.1, 0.4, 0.5])\nprint(v0)\n\n[[0.1 0.4 0.5]]\n\n\nWe can simulate the probabilities of the next step given the transition matrix.\n\nv1 = v0*T\nprint(v1)\n\n[[0.46 0.15 0.39]]\n\n\nFollowing this again we can simulate the states after two steps\n\nv2 = v1*T\nprint(v2)\n\n[[0.316 0.139 0.545]]\n\n\nThere’s a convenient way to calculate the next step given the starting condition.\n\nprint(v0*T**2)\n\n[[0.316 0.139 0.545]]\n\n\nWhat happens if we continue doing this for a long time?\n\nprint(v0*T**100)\n\n[[0.35714286 0.14935065 0.49350649]]\n\n\nAnd how does this change when taking the next step?\n\nprint(v0*T**101)\n\n[[0.35714286 0.14935065 0.49350649]]\n\n\nThis Markov Chain has the property of being a stationary distribution. That satisfies the following\n\\[ \\pi = \\pi T. \\]\nOur objective is to estimate \\(\\pi\\), which represents the target distribution.\nThis behaviour of the Markov Chain is only satisfied if two conditions are met.\n\nThe Markov Chain is irreducible\n\nAny point in the Markov chain can be reached by any other point\n\nThe Markov Chain is aperiodic Any point can be reached by any other point in a single step",
    "crumbs": [
      "Course materials",
      "Metropolis Hastings"
    ]
  },
  {
    "objectID": "metropolis-hastings.html#markov-chain-monte-carlo",
    "href": "metropolis-hastings.html#markov-chain-monte-carlo",
    "title": "Metropolis Hastings",
    "section": "Markov Chain Monte Carlo",
    "text": "Markov Chain Monte Carlo\nIf we are able to draw samples from a Markov Chain that satisfies these properties we can generate samples from the stationary proposal distribution. After drawing samples from the sample distribution we can investigate the quantities of interest using Monte Carlo integration (read: counting samples).\nOne property that is not required for a Markov Chain but satisfies the above two properties is the detailed balance. This is not a requirement, but it’s pretty easy to define a detailed balance rather than to define general balance. This ensures that the Markov chain is reversible, in other words\n\\[ \\pi(x)*T(x'|x) = \\pi(x')*T(x|x')\\].\nIf we define a reducible process it is defined to be irreducible and aperiodic by default. It is a periodic because you can always go back, and irreducible because a region cannot be entered if there is no way of returning.\nThe process of generating a Markov Chain with these properties means that we know we are sampling from a stationary target distribution, if we have enough samples.",
    "crumbs": [
      "Course materials",
      "Metropolis Hastings"
    ]
  },
  {
    "objectID": "metropolis-hastings.html#going-from-discrete-to-continuous",
    "href": "metropolis-hastings.html#going-from-discrete-to-continuous",
    "title": "Metropolis Hastings",
    "section": "Going from discrete to continuous",
    "text": "Going from discrete to continuous\nRather than the previous graph networks described before we can expand this to the continuous number line.\nNote: This isn’t always a possibility to transition between discrete and continuous number lines, it just works out for this case\nRather than sampling from \\(\\pi(x)\\), representing the discrete case, we will change the notation to \\(p(x)\\). And the transition kernel, rather than a matrix \\(T(x'|x)\\) will be represented by \\(K(x'|x).\\)\n\nMetropolis-Hastings\nMetropolis-Hastings enforces the reversibility constraint using the accept-reject function\n\\[\nA(x,x') = min(1, \\frac{p(x')g(x|x')}{p(x)g(x'|x)})\n\\]\nand often, a symmetric proposal distribution, e.g.\n\\[\ng(x'|x) = N(x, \\sigma).\n\\]\nThe resulting kernel is represented as\n\\[\nK(x'|x) = g(x'|x)*A(x,x').\n\\]\nThe accept-reject function, and the symmetric proposal distribution were chosen to satisfy the detailed balance function\n\\[\np(x)g(x'|x)A(x,x') = p(x')g(x|x')A(x,x').\n\\]\nTherefore, if we draw samples using the Metropolis-Hastings algorithm, we draw samples from the target distribution \\(p(x)\\).",
    "crumbs": [
      "Course materials",
      "Metropolis Hastings"
    ]
  },
  {
    "objectID": "metropolis-hastings.html#coding-the-metropolis-hastings-in-practice",
    "href": "metropolis-hastings.html#coding-the-metropolis-hastings-in-practice",
    "title": "Metropolis Hastings",
    "section": "Coding the Metropolis Hastings in practice",
    "text": "Coding the Metropolis Hastings in practice\n\nPart 1: sampling from a normal distribution\nGiven a \\(p(x) = N(2, 0.5)\\) how would draw samples using the Metropolis-Hastings algorithm?\n\nChoose proposal value\nEvaluate probability ratio\nAccept-Reject\nincrement step\n\n\nDefine probability density function\n\nimport numpy as np\nfrom scipy.stats import norm\n\ndef prob(x):\n  return norm.pdf(x, 2, 0.5)\n\n\n\nDefine proposal distribution\n\ndef proposal(x):\n  return norm.rvs(x, 1, 1)[0]\n\n\n\nInitialise sampler\n\ncurrent = 0.0\nsamples = [current]\n\n\n\nSample from distribution\n\nfor i in range(10000):\n    prop = proposal(current)\n    accept_reject = prob(prop)/prob(current)\n    if accept_reject &gt; 1:\n        samples.append(prop)\n        current = prop\n    else:\n        cutoff = np.random.rand(1)[0]\n        if accept_reject &gt; cutoff:\n            samples.append(prop)\n            current = prop\n\n\n\nPlot distribution\n\nimport matplotlib.pyplot as plt\nplt.hist(samples)\n\n(array([   5.,   53.,  291.,  854., 1329., 1376.,  811.,  290.,   36.,\n           5.]),\n array([0.        , 0.4010916 , 0.8021832 , 1.2032748 , 1.6043664 ,\n        2.005458  , 2.4065496 , 2.8076412 , 3.2087328 , 3.60982439,\n        4.01091599]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\n\n\n\n\nTrace plot\n\ndraw = [draw for draw, _ in enumerate(samples)]\nplt.plot(draw, samples)\n\n\n\n\n\n\n\n\n\n\n\nPart 2: determining mean and standard deviation from data\nI suggest using logs due to numerical issues. Here’s an example function which you can use to evaluate the probability of the data.\n\ndef eval_prob(data, mu, sigma):\n    return np.log(norm.pdf(data,mu,sigma)).sum()\n\nHere’s also a multivariate random number generator to generate proposals.\n\ndef proposal_multi(mu, sigma):\n    mean = [mu, sigma]\n    cov = [[0.2, 0], [0, 0.2]]  # diagonal covariance\n    return np.random.multivariate_normal(mean, cov, 1)[0]\n\nHere is how you’d call the proposal function\nprop_mu, prop_sigma = proposal_multi(current_mu, current_sigma)\nthe accept_reject probability should also be updated to account for the log-probability\naccept_reject = np.exp(prob_prop - prob_current)\nYou should sample a 95% interval including a \\(\\mu = 5\\) and a \\(\\sigma = 0.2\\). This may be difficult at first to sample and I would recommend initialising at these values.",
    "crumbs": [
      "Course materials",
      "Metropolis Hastings"
    ]
  },
  {
    "objectID": "metropolis-hastings.html#volume-in-hyperspace-dont-make-much-sense",
    "href": "metropolis-hastings.html#volume-in-hyperspace-dont-make-much-sense",
    "title": "Metropolis Hastings",
    "section": "Volume in hyperspace don’t make much sense",
    "text": "Volume in hyperspace don’t make much sense\nGiven an n-dimensional cube of length=2 you place spheres of diameter=1 in each of the corners and then place another sphere in the middle.\nHow does the size of the middle sphere change as dimensions increase?\n\n\nRadius of middle sphere as dimension increases",
    "crumbs": [
      "Course materials",
      "Metropolis Hastings"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html",
    "href": "introduction_to_bayesian_inference.html",
    "title": "Introduction to Bayesian inference",
    "section": "",
    "text": "What is Bayesian statistical inference?\nWhy is it useful?\nThe big challenge\n\n\n\n\nSet up git/ssh, Python, cmdstanpy and cmdstan",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#introduction",
    "href": "introduction_to_bayesian_inference.html#introduction",
    "title": "Introduction to Bayesian inference",
    "section": "",
    "text": "What is Bayesian statistical inference?\nWhy is it useful?\nThe big challenge\n\n\n\n\nSet up git/ssh, Python, cmdstanpy and cmdstan",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#probability-function",
    "href": "introduction_to_bayesian_inference.html#probability-function",
    "title": "Introduction to Bayesian inference",
    "section": "Probability function",
    "text": "Probability function\n\n\n\n\n\n\nFigure 1: A jug of water\n\n\n\nA function that can measure the water in a jug.\ni.e.\n\\(p: S \\rightarrow [0,1]\\) where\n\n\\(S\\) is an event space\nIf \\(A, B \\in S\\) are disjoint, then \\(p(A\\cup B) = p(A) + p(B)\\)",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#bayesian-epistemology",
    "href": "introduction_to_bayesian_inference.html#bayesian-epistemology",
    "title": "Introduction to Bayesian inference",
    "section": "Bayesian epistemology",
    "text": "Bayesian epistemology\nProbability functions can describe belief, e.g.\n\n\n“Definitely B”:\n\n\n“Not sure if A or B”:\n\n\n“B a bit more plausible than A”:",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#statistical-inference",
    "href": "introduction_to_bayesian_inference.html#statistical-inference",
    "title": "Introduction to Bayesian inference",
    "section": "Statistical Inference",
    "text": "Statistical Inference\n\n\n\n\n\n\nFigure 2: A nice soup: here is the recipe\n\n\n\nIn: facts about a spoonful sample\nOut: propositions about a soup population\ne.g.\n\nspoonful not salty \\(\\rightarrow\\) soup not salty\nno carrots in spoon \\(\\rightarrow\\) no carrots in soup",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#bayesian-statistical-inference",
    "href": "introduction_to_bayesian_inference.html#bayesian-statistical-inference",
    "title": "Introduction to Bayesian inference",
    "section": "Bayesian statistical inference",
    "text": "Bayesian statistical inference\n\n\n\n\n\n\nFigure 3: A jug of soup\n\n\n\nStatistical inference resulting in a probability.\ne.g.\n\nspoon \\(\\rightarrow\\) \\(p(\\text{soup not salty})\\) = 99.9%\nspoon \\(\\rightarrow\\) \\(p(\\text{no carrots in soup})\\) = 95.1%\n\nNon-Bayesian inferences:\n\nspoon \\(\\rightarrow\\) Best estimate of [salt] is 0.1mol/l\n\\(p_{null}(\\text{spoon})\\) = 4.9% \\(\\rightarrow\\) no carrots (p=0.049)",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#general-reasons",
    "href": "introduction_to_bayesian_inference.html#general-reasons",
    "title": "Introduction to Bayesian inference",
    "section": "General reasons",
    "text": "General reasons\n\nEasy to interpret\n\n\n\n\n\n\nFigure 4: It’s a good book!\n\n\n\nBayesian inference produces probabilities, which can be interpreted in terms of information and plausible reasoning.\ne.g. “According to the model…”\n\n“…x is highly plausible.”\n“…x is more plausible than y.”\n“…the data doesn’t contain enough information for firm conclusions about x.”\n\n\n\nOld\n\n\n\n\n\n\n(https://en.wikipedia.org/wiki/Pierre-Simon_Laplace)\n\n\n\n\nFigure 5: Laplace, who did Bayesian inference in the 1780s\n\n\n\nBayesian inference is old!\nThis means\n\nit is well understood mathematically.\nconceptual surprises are relatively rare.\nthere are many compatible frameworks.\n\n\n\nAn easy way to represent your information\nProbabilities decompose nicely:\n\\[\np(\\theta, y) = p(\\theta)p(y\\mid\\hat{y}(\\theta))\n\\]\n\n\\(p(\\theta)\\): nice form for background information, e.g. anything non-experimental\n\\(\\hat{y}(\\theta)\\): nice form for structural information, e.g. physical laws\n\\(p(y\\mid\\hat{y}(\\theta))\\): nice form for measurement information, e.g. instrument accuracy",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#reasons-specific-to-computational-biology",
    "href": "introduction_to_bayesian_inference.html#reasons-specific-to-computational-biology",
    "title": "Introduction to Bayesian inference",
    "section": "Reasons specific to computational biology",
    "text": "Reasons specific to computational biology\n\nRegression models: good for describing measurements\nRegression: measured value noisily depends on the true value e.g. \\(y \\sim N(\\hat{y}, \\sigma)\\).\nBiology experiments often have measurement processes with awkward features. e.g.\n\nheteroskedasticity (amount of noise depends on measured value)\nconstraints (e.g. non-negativity, compositionality)\nunknown latent bias (e.g. the pump is supposed to add \\(0.05cm^3\\) per min, but does it?)\n\nBayesian inference is good at describing these.\n\n\nMulti-level models: good for describing sources of variation\n\n\n\n\n\n\nFigure 6: plot from https://github.com/teddygroves/baseball\n\n\n\nMeasurement model:\n\\(y \\sim binomial(K, logit(ability))\\)\nGpareto model:\n\\(ability \\sim GPareto(m, k, s)\\)\nNormal model:\n\\(ability \\sim N(\\mu, \\tau)\\)\n\n\nGenerative models: good for representing structural information\n\n\n\n\n\n\nFigure 7: From a Stan case study\n\n\n\nInformation about hares (\\(u\\)) and lynxes (\\(v\\)):\n\\[\\begin{align*}\n\\frac{d}{dt}u &= (\\alpha - \\beta v)u \\\\\n\\frac{d}{dt}v &= (-\\gamma + \\delta u)v\n\\end{align*}\\]\ni.e. a deterministic function turning \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\), \\(\\delta\\), \\(u(0)\\) and \\(v(0)\\) into \\(u(t)\\) and \\(v(t)\\).",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#the-solution-mcmc",
    "href": "introduction_to_bayesian_inference.html#the-solution-mcmc",
    "title": "Introduction to Bayesian inference",
    "section": "The solution: MCMC",
    "text": "The solution: MCMC\n\n\n\n\n\n\nFigure 8: An image I found online\n\n\n\nStrategy:\n\nFind a series of numbers that\n\nquickly finds the high-probabiliy region in parameter space\nreliably matches its statistical properties\n\nDo sample-based approximate integration.\n\nIt (often) works!\nWe can tell when it doesn’t work!",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#things-to-read",
    "href": "introduction_to_bayesian_inference.html#things-to-read",
    "title": "Introduction to Bayesian inference",
    "section": "Things to read",
    "text": "Things to read\nBox and Tiao (1992, Ch. 1.1) (available from dtu findit) gives a nice explanation of statistical inference in general and why Bayes.\nHistorical interest:\n\nLaplace (1986) and Stigler (1986)\nJaynes (2003) Preface",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#things-to-set-up",
    "href": "introduction_to_bayesian_inference.html#things-to-set-up",
    "title": "Introduction to Bayesian inference",
    "section": "Things to set up",
    "text": "Things to set up\n\nPython\nFirst get a recent (ideally 3.11+) version of Python This can be very annoying so talk to me if necessary!\nNext get used to Python virtual environments.\nThe method I like is to put the virtual environment in a folder .venv inside the root of my project:\n$ python -m venv .venv --prompt=bscb\nThen to use: Tip: use an ergonomic alias to activate venvs e.g. alias va=\"source .venv/bin/activate\"\n$ source .venv/bin/activate\n# ... do work\n$ deactivate\n\n\nGit and ssh\ngit clone git@github.com:teddygroves/bayesian_statistics_for_systems_biologists.git\n\n\nCmdstanpy and cmdstan\nFirst install them:\n$ pip install cmdstanpy\n$ python -m cmdstanpy.instsall_cmdstan\nNow test if they work\nfrom cmdstanpy import CmdStanModel\nfilename = \"example_stan_program.stan\" \ncode = \"data {} parameters {real t;} model {t ~ std_normal();}\"\nwith open(filename, \"w\") as f:\n    f.write(code)\nmodel = CmdStanModel(stan_file=filename)\nmcmc = model.sample()",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#theory",
    "href": "introduction_to_bayesian_inference.html#theory",
    "title": "Introduction to Bayesian inference",
    "section": "Theory",
    "text": "Theory\nHamiltonian Monte Carlo:\n\nwhat?\nwhy?\n\nMCMC diagnostics",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "introduction_to_bayesian_inference.html#computer",
    "href": "introduction_to_bayesian_inference.html#computer",
    "title": "Introduction to Bayesian inference",
    "section": "Computer",
    "text": "Computer\nStan, cmdstanpy, arviz:\n\nformats\nworkflow\nwrite a model",
    "crumbs": [
      "Course materials",
      "Introduction to Bayesian inference"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome!",
    "section": "",
    "text": "This is a course about Bayesian statistics, targeted at systems biologists.\nThere are three intended learning outcomes:\n\nUnderstand the theoretical basis for applying Bayesian data analysis to practical scientific problems\nDevelop a familiarity with implementing Bayesian data analysis using modern software tools\nGain deep understanding of both theory and practice of elements of Bayesian data analysis that are particularly relevant to computational biology, including custom hierarchical models, large analyses and statistical models with embedded ODE systems.\n\n\n\nEach week we have a one-hour seminar. The goal is to spend the time approximately as follows:\n\n25-35mins on ‘theory’, aka learning things from the book and getting more reading material\n25-35mins on practical computer work\n\n\n\n\n\n\n\n\nStatistical inference in general\nBayesian statistical inference\nThe big challenge: dimensionality\n\n\n\nSet up development environment\ngit basics\nInstall Stan and cmdstanpy\n\n\n\nJaynes (2003, Ch. 1)\nLaplace (1986)\nBox and Tiao (1992, Ch. 1.1)\n\n\n\n\n\n\nWhat is MCMC?\nHamiltonian Monte Carlo\nProbabilistic programming\n\n\n\nRun an MCMC algorithm and inspect the results\n\n\n\nBetancourt (2018)\n\n\n\n\n\n\n\n\n\nDiagnostics: convergence, divergent transitions, effective sample size\nModel evaluation as decision theory\nWhy negative log likelihood is a good default loss function\n\n\n\nDiagnose some good and bad MCMC runs\n\n\n\nVehtari et al. (2021)\nVehtari, Gelman, and Gabry (2017)\n\n\n\n\n\n\nGeneralised linear models\nPrior elicitation\nHierarchical models\n\n\n\nCompare some statistical models of a simulated biological dataset\n\n\n\nBetancourt (2024)\n\n\n\n\n\n\n\n\n\nWhat is an ODE?\nODE solvers\nODE solvers inside probabilistic programs\n\n\n\nFit a model with an ODE.\n\n\n\nTimonen et al. (2022)\n\n\n\n\n\n\nParts of a statistical anlaysis (not just inference!)\nWhy Bayesian workflow is complex: non-linearity and plurality\nWriting scalable statistical programming projects\n\n\n\nWrite a scalable statistical analysis with bibat.\n\n\n\nGelman et al. (2020)\n\n\n\n\nFormat: one hour joint feedback and help session",
    "crumbs": [
      "Admin",
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#general-format",
    "href": "index.html#general-format",
    "title": "Welcome!",
    "section": "",
    "text": "Each week we have a one-hour seminar. The goal is to spend the time approximately as follows:\n\n25-35mins on ‘theory’, aka learning things from the book and getting more reading material\n25-35mins on practical computer work",
    "crumbs": [
      "Admin",
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#plan",
    "href": "index.html#plan",
    "title": "Welcome!",
    "section": "",
    "text": "Statistical inference in general\nBayesian statistical inference\nThe big challenge: dimensionality\n\n\n\nSet up development environment\ngit basics\nInstall Stan and cmdstanpy\n\n\n\nJaynes (2003, Ch. 1)\nLaplace (1986)\nBox and Tiao (1992, Ch. 1.1)\n\n\n\n\n\n\nWhat is MCMC?\nHamiltonian Monte Carlo\nProbabilistic programming\n\n\n\nRun an MCMC algorithm and inspect the results\n\n\n\nBetancourt (2018)\n\n\n\n\n\n\n\n\n\nDiagnostics: convergence, divergent transitions, effective sample size\nModel evaluation as decision theory\nWhy negative log likelihood is a good default loss function\n\n\n\nDiagnose some good and bad MCMC runs\n\n\n\nVehtari et al. (2021)\nVehtari, Gelman, and Gabry (2017)\n\n\n\n\n\n\nGeneralised linear models\nPrior elicitation\nHierarchical models\n\n\n\nCompare some statistical models of a simulated biological dataset\n\n\n\nBetancourt (2024)\n\n\n\n\n\n\n\n\n\nWhat is an ODE?\nODE solvers\nODE solvers inside probabilistic programs\n\n\n\nFit a model with an ODE.\n\n\n\nTimonen et al. (2022)\n\n\n\n\n\n\nParts of a statistical anlaysis (not just inference!)\nWhy Bayesian workflow is complex: non-linearity and plurality\nWriting scalable statistical programming projects\n\n\n\nWrite a scalable statistical analysis with bibat.\n\n\n\nGelman et al. (2020)\n\n\n\n\nFormat: one hour joint feedback and help session",
    "crumbs": [
      "Admin",
      "Welcome!"
    ]
  },
  {
    "objectID": "mcmc_and_stan.html",
    "href": "mcmc_and_stan.html",
    "title": "MCMC and Stan",
    "section": "",
    "text": "Welcome back!\nPlan for today:\n\nMCMC\nGetting started with Stan in Python\n\n\n\n\n\n\nIn A rule for evaluating the target function and maybe its gradients\nOut: A Markov Chain of numbers that you can do Monte Carlo integration with.\n\n\n\n\n\n\nOne random variable \\(X\\) with probability density function \\(density\\).\nAka a “one-dimensional parameter space”.\nEvaluating \\(density(x)\\) for a given value \\(x\\) (aka “point in parameter space”) is easy.\nCalculating the area under a region of the \\(density\\) curve (aka “the probability mass”) is expensive.\nThis is annoying, we need to know that!\n\n\n\nGenerate a series \\(x_1, ..., x_i,..., x_n\\) where every number depends on the previous number(s), i.e. a Markov chain.\nTo calculate \\(x_{i+1}\\), generate a random number and take into account \\(density(x_i)\\). 1\n1 This is the interesting and tricky bit!\nIf this works, with a long enough series of numbers we get something like this:\n\n\n\n\n\n\n\nSuccess condition for MCMC\n\n\n\nThe numbers from the Markov chain have to approximately agree with the target density function, i.e. in any region the number of dots is approximately proportional to the area under the curve.\n\n\nNow we can do Monte Carlo integration, i.e. approximate the area under a region of curve by counting the red dots in that region.\n\n\n\n\nThe first (I think?) MCMC algorithm. Original paper: Metropolis et al. (1953).2\n2 Metropolis was first author but didn’t do any work! That was Arianna Rosenbluth (programming) plus Marshall Rosenbluth & Edward Teller (maths)Generates Markov chains that provably agree with arbitrary target density functions (in the asymptotic limit).\nRoughly how it works:\n\nChoose candidate by randomly perturbing previous point \\(x_i\\)\nAccept or reject candidate randomly according to the ratio \\(\\frac{density(candidate)}{density(x_i)}\\)\n\\(x_{i+1}\\) is candidate if accept else x_i\n\nVisualisation\nDoesn’t work for more than ~10 dimensional parameter spaces.\n\n\n\nBig picture: MCMC that works for large parameter spaces.\nKey innovation: travel through parameter space quickly using gradients.\nIllustration:\n\nA better illustration\n\n\n\n\n\n\nA small but important detail:\n\n\n\nTo decide how hard to flick the ball and how precisely to calculate its trajectory for a particular case, adaptation is required, i.e. running the algorithm in warm-up mode for a bit and learning by trial and error. How best to do adaptation is an important open question.\n\n\nLimitations:\n\nNo discrete parameters\nPerforms badly when the target (log-scale) density function is wiggly.\n\n\n\nBetancourt (2018b)\nBetancourt (2018a)\nBeskos et al. (2010)\nAndrieu and Andrieu (2003)\n\n\n\n\n\nStan is:\n\nA language for specifying probability density functions as Stan programs.\nA compiler that turns Stan programs into instructions for inference engines.\nAn inference engine implementing adaptive HMC and some other algorithms.\nA library of functions for calculating the gradients of interesting probability density functions.\nSome interfaces for popular computer tools:\n\nCommand line: cmdstan\nPython:\n\ncmdstanpy\npystan\n\nR:\n\ncmdstanr\nRstan\n\n\n\n\n\nAlternatives: pymc, blackjax, Turing.jl tensorflow probability\nOverview as of 2023: Štrumbelj et al. (2023).\nWhy I like Stan:\n\nBig, active and knowledgeable community (most important reason)\nFeatureful (complex numbers, fast solvers, up-to-date diagnostics)\nFast (for CPU-bound, general purpose adaptive HMC)\n\n\n\n\n\nInstall cmdstanpy\npip install cmdstanpy\nUse cmdstanpy to install the rest of Stan\npython -m cmdstanpy.install_cmdstan --cores 2\nI like to store Stan outputs using the library arviz. It also makes nice plots.\npip install arviz\n\n\nA Stan program consists of function definitions, variable declarations and statements, organised into {...} delimited blocks, e.g.\ndata {\n  real y;  # a variable declaration\n}\nmodel {\n  y ~ normal(0, 1.4);  # a statement\n}\nThe purpose of a Stan program is to define the probability density for any combination of data and parameters.\nIt is ok for there to be no parameters:\ntransformed data {\n  real y = 2;  # this is both a statement and a declaration!\n}\nmodel {\n  y ~ normal(0, 1.4);  # the total density is N(2 | 0, 1.4) = 0.103\n}\nor no data:\nparameters {\n  real alpha;\n}\nmodel {\n  alpha ~ normal(0, 1.4);  # Stan can find the density for any alpha\n}\n\n\n\n\n\nUse standard Python tools to make a dictionary mapping data variables to inputs e.g.\nmy_stan_input = {\"y\": 2}\n(Optional) Save the input as a json file:\nimport json\nwith open(\"my_stan_input.json\", \"w\") as f:\n    json.dump(my_stan_input, f)\n\n\n\nInstantiate a CmdstanModel\nfrom cmdstanpy import CmdStanModel\nmy_model = CmdStanModel(stan_file=\"my_stan_program.stan\")\nCmdstanpy will use Stan’s compiler to create .hpp and executable files.\n\n\n\nUse the method CmdStanModel.sample to trigger adaptive HMC.\nmy_mcmc_results = my_model.sample(data=my_stan_input)\n\n\n\nUse the methods CmdStanMCMC.diagnose and CmdStanMCMC.summary for quick diagnostics.\nsummary = my_mcmc_results.summary()\ndiagnostics = my_mcmc_results.diagnose()\n\n\n\nConvert to arviz InferenceData and save\nimport arviz\nmy_idata = arviz.from_cmdstanpy(my_mcmc_results)\nmy_idata.to_json(\"my_arviz_idata.json\")\n\n\n\n\nCmdstanpy docs\nStan reference manual\nStan functions reference\nStan User’s guide\nstan-dev github organisation",
    "crumbs": [
      "Course materials",
      "MCMC and Stan"
    ]
  },
  {
    "objectID": "mcmc_and_stan.html#introduction",
    "href": "mcmc_and_stan.html#introduction",
    "title": "MCMC and Stan",
    "section": "",
    "text": "Welcome back!\nPlan for today:\n\nMCMC\nGetting started with Stan in Python",
    "crumbs": [
      "Course materials",
      "MCMC and Stan"
    ]
  },
  {
    "objectID": "mcmc_and_stan.html#mcmc",
    "href": "mcmc_and_stan.html#mcmc",
    "title": "MCMC and Stan",
    "section": "",
    "text": "In A rule for evaluating the target function and maybe its gradients\nOut: A Markov Chain of numbers that you can do Monte Carlo integration with.\n\n\n\n\n\n\nOne random variable \\(X\\) with probability density function \\(density\\).\nAka a “one-dimensional parameter space”.\nEvaluating \\(density(x)\\) for a given value \\(x\\) (aka “point in parameter space”) is easy.\nCalculating the area under a region of the \\(density\\) curve (aka “the probability mass”) is expensive.\nThis is annoying, we need to know that!\n\n\n\nGenerate a series \\(x_1, ..., x_i,..., x_n\\) where every number depends on the previous number(s), i.e. a Markov chain.\nTo calculate \\(x_{i+1}\\), generate a random number and take into account \\(density(x_i)\\). 1\n1 This is the interesting and tricky bit!\nIf this works, with a long enough series of numbers we get something like this:\n\n\n\n\n\n\n\nSuccess condition for MCMC\n\n\n\nThe numbers from the Markov chain have to approximately agree with the target density function, i.e. in any region the number of dots is approximately proportional to the area under the curve.\n\n\nNow we can do Monte Carlo integration, i.e. approximate the area under a region of curve by counting the red dots in that region.\n\n\n\n\nThe first (I think?) MCMC algorithm. Original paper: Metropolis et al. (1953).2\n2 Metropolis was first author but didn’t do any work! That was Arianna Rosenbluth (programming) plus Marshall Rosenbluth & Edward Teller (maths)Generates Markov chains that provably agree with arbitrary target density functions (in the asymptotic limit).\nRoughly how it works:\n\nChoose candidate by randomly perturbing previous point \\(x_i\\)\nAccept or reject candidate randomly according to the ratio \\(\\frac{density(candidate)}{density(x_i)}\\)\n\\(x_{i+1}\\) is candidate if accept else x_i\n\nVisualisation\nDoesn’t work for more than ~10 dimensional parameter spaces.\n\n\n\nBig picture: MCMC that works for large parameter spaces.\nKey innovation: travel through parameter space quickly using gradients.\nIllustration:\n\nA better illustration\n\n\n\n\n\n\nA small but important detail:\n\n\n\nTo decide how hard to flick the ball and how precisely to calculate its trajectory for a particular case, adaptation is required, i.e. running the algorithm in warm-up mode for a bit and learning by trial and error. How best to do adaptation is an important open question.\n\n\nLimitations:\n\nNo discrete parameters\nPerforms badly when the target (log-scale) density function is wiggly.\n\n\n\nBetancourt (2018b)\nBetancourt (2018a)\nBeskos et al. (2010)\nAndrieu and Andrieu (2003)",
    "crumbs": [
      "Course materials",
      "MCMC and Stan"
    ]
  },
  {
    "objectID": "mcmc_and_stan.html#stan",
    "href": "mcmc_and_stan.html#stan",
    "title": "MCMC and Stan",
    "section": "",
    "text": "Stan is:\n\nA language for specifying probability density functions as Stan programs.\nA compiler that turns Stan programs into instructions for inference engines.\nAn inference engine implementing adaptive HMC and some other algorithms.\nA library of functions for calculating the gradients of interesting probability density functions.\nSome interfaces for popular computer tools:\n\nCommand line: cmdstan\nPython:\n\ncmdstanpy\npystan\n\nR:\n\ncmdstanr\nRstan\n\n\n\n\n\nAlternatives: pymc, blackjax, Turing.jl tensorflow probability\nOverview as of 2023: Štrumbelj et al. (2023).\nWhy I like Stan:\n\nBig, active and knowledgeable community (most important reason)\nFeatureful (complex numbers, fast solvers, up-to-date diagnostics)\nFast (for CPU-bound, general purpose adaptive HMC)",
    "crumbs": [
      "Course materials",
      "MCMC and Stan"
    ]
  },
  {
    "objectID": "mcmc_and_stan.html#getting-started-with-stan-in-python",
    "href": "mcmc_and_stan.html#getting-started-with-stan-in-python",
    "title": "MCMC and Stan",
    "section": "",
    "text": "Install cmdstanpy\npip install cmdstanpy\nUse cmdstanpy to install the rest of Stan\npython -m cmdstanpy.install_cmdstan --cores 2\nI like to store Stan outputs using the library arviz. It also makes nice plots.\npip install arviz\n\n\nA Stan program consists of function definitions, variable declarations and statements, organised into {...} delimited blocks, e.g.\ndata {\n  real y;  # a variable declaration\n}\nmodel {\n  y ~ normal(0, 1.4);  # a statement\n}\nThe purpose of a Stan program is to define the probability density for any combination of data and parameters.\nIt is ok for there to be no parameters:\ntransformed data {\n  real y = 2;  # this is both a statement and a declaration!\n}\nmodel {\n  y ~ normal(0, 1.4);  # the total density is N(2 | 0, 1.4) = 0.103\n}\nor no data:\nparameters {\n  real alpha;\n}\nmodel {\n  alpha ~ normal(0, 1.4);  # Stan can find the density for any alpha\n}\n\n\n\n\n\nUse standard Python tools to make a dictionary mapping data variables to inputs e.g.\nmy_stan_input = {\"y\": 2}\n(Optional) Save the input as a json file:\nimport json\nwith open(\"my_stan_input.json\", \"w\") as f:\n    json.dump(my_stan_input, f)\n\n\n\nInstantiate a CmdstanModel\nfrom cmdstanpy import CmdStanModel\nmy_model = CmdStanModel(stan_file=\"my_stan_program.stan\")\nCmdstanpy will use Stan’s compiler to create .hpp and executable files.\n\n\n\nUse the method CmdStanModel.sample to trigger adaptive HMC.\nmy_mcmc_results = my_model.sample(data=my_stan_input)\n\n\n\nUse the methods CmdStanMCMC.diagnose and CmdStanMCMC.summary for quick diagnostics.\nsummary = my_mcmc_results.summary()\ndiagnostics = my_mcmc_results.diagnose()\n\n\n\nConvert to arviz InferenceData and save\nimport arviz\nmy_idata = arviz.from_cmdstanpy(my_mcmc_results)\nmy_idata.to_json(\"my_arviz_idata.json\")\n\n\n\n\nCmdstanpy docs\nStan reference manual\nStan functions reference\nStan User’s guide\nstan-dev github organisation",
    "crumbs": [
      "Course materials",
      "MCMC and Stan"
    ]
  },
  {
    "objectID": "regression.html",
    "href": "regression.html",
    "title": "Regression models for describing measurements",
    "section": "",
    "text": "Regression is a nice way of modelling measurements.\nMaybe you have seen this regression model before:\n\\[\ny = \\alpha + X\\cdot\\beta + \\epsilon\n\\]\nComponents:\n\n\\(y\\): a measurement\n\\(\\alpha\\) and \\(\\beta\\) some unknown parameters, the same for every measurement\n\\(X\\) some real-valued features\n\\(\\epsilon\\) an unknown number quantifying the difference between the prediction and the observation, different for each measurement\n\nOften \\(\\epsilon\\) is assumed to have a normal distribution with location zero and scale parameter \\(\\sigma\\).\nAnother way of saying the same thing:\n\\[\ny \\sim N(\\alpha + X\\cdot\\beta, \\sigma)\n\\]\nI prefer this notation because it nicely separates the different components, and doesn’t hide the error parameter \\(\\sigma\\). It also makes it clear what you might change. For example \\(\\alpha + X\\cdot\\beta\\) is just one option: there are many ways in which measurements and predictors can be related. The normal distribution is also not required, in fact it is often inappropriate.\nThe key features of a regression model:\n\na predictor that is some function of the parameters and features\na probabilistic relationship between the predictor and the measurement\n\n\n\n\n\n\n\nImportant\n\n\n\nIn the context of regression modelling, Bayesian inference lets you give free rein to your creativity when designing regressions, so you can make models that represent what you know about the measurement process.\n\n\n\n\nThis is a popular and powerful class of regression model with the following distinguishing characteristics:\n\nThe predictor is a linear function of the parameters and features, e.g.  \\(\\alpha + X\\cdot\\beta\\)\nThe probability distribution describing measurement errors is not necessarily the normal distribution, e.g. log-normal, Poisson, Dirichlet, Gamma, …\nThere is a link function that connects the linear predictor with the probability distribution, e.g. \\(\\ln(\\alpha + X\\cdot\\beta)\\).\n\nAn example GLM for positive-constrained measurements:\n\\[\ny \\sim LN(\\ln(\\alpha+X\\cdot\\beta), \\sigma)\n\\]\n\n\n\n\nStart with the simplest GLM that obeys all known data constraints.\nTry log-transforming things.\nAim to explicitly represent how you think the measurement apparatus works.\nHeavy tailed distributions are often better than the normal distribution.\nRemember that varying measurement error is an option.\n\n\n\n\n\nA practical guide to regression modelling: Gelman, Hill, and Vehtari (2020)\nThe section of the Stan user’s guide on regression models is really nice.\nModern Statistics for Modern Biology is an online (and physical) textbook with some very good material about biology-relevant regression models: Susan Holmes and Wolfgang Huber (2019).",
    "crumbs": [
      "Course materials",
      "Regression models for describing measurements"
    ]
  },
  {
    "objectID": "regression.html#what-is-regression",
    "href": "regression.html#what-is-regression",
    "title": "Regression models for describing measurements",
    "section": "",
    "text": "Regression is a nice way of modelling measurements.\nMaybe you have seen this regression model before:\n\\[\ny = \\alpha + X\\cdot\\beta + \\epsilon\n\\]\nComponents:\n\n\\(y\\): a measurement\n\\(\\alpha\\) and \\(\\beta\\) some unknown parameters, the same for every measurement\n\\(X\\) some real-valued features\n\\(\\epsilon\\) an unknown number quantifying the difference between the prediction and the observation, different for each measurement\n\nOften \\(\\epsilon\\) is assumed to have a normal distribution with location zero and scale parameter \\(\\sigma\\).\nAnother way of saying the same thing:\n\\[\ny \\sim N(\\alpha + X\\cdot\\beta, \\sigma)\n\\]\nI prefer this notation because it nicely separates the different components, and doesn’t hide the error parameter \\(\\sigma\\). It also makes it clear what you might change. For example \\(\\alpha + X\\cdot\\beta\\) is just one option: there are many ways in which measurements and predictors can be related. The normal distribution is also not required, in fact it is often inappropriate.\nThe key features of a regression model:\n\na predictor that is some function of the parameters and features\na probabilistic relationship between the predictor and the measurement\n\n\n\n\n\n\n\nImportant\n\n\n\nIn the context of regression modelling, Bayesian inference lets you give free rein to your creativity when designing regressions, so you can make models that represent what you know about the measurement process.\n\n\n\n\nThis is a popular and powerful class of regression model with the following distinguishing characteristics:\n\nThe predictor is a linear function of the parameters and features, e.g.  \\(\\alpha + X\\cdot\\beta\\)\nThe probability distribution describing measurement errors is not necessarily the normal distribution, e.g. log-normal, Poisson, Dirichlet, Gamma, …\nThere is a link function that connects the linear predictor with the probability distribution, e.g. \\(\\ln(\\alpha + X\\cdot\\beta)\\).\n\nAn example GLM for positive-constrained measurements:\n\\[\ny \\sim LN(\\ln(\\alpha+X\\cdot\\beta), \\sigma)\n\\]\n\n\n\n\nStart with the simplest GLM that obeys all known data constraints.\nTry log-transforming things.\nAim to explicitly represent how you think the measurement apparatus works.\nHeavy tailed distributions are often better than the normal distribution.\nRemember that varying measurement error is an option.\n\n\n\n\n\nA practical guide to regression modelling: Gelman, Hill, and Vehtari (2020)\nThe section of the Stan user’s guide on regression models is really nice.\nModern Statistics for Modern Biology is an online (and physical) textbook with some very good material about biology-relevant regression models: Susan Holmes and Wolfgang Huber (2019).",
    "crumbs": [
      "Course materials",
      "Regression models for describing measurements"
    ]
  },
  {
    "objectID": "regression.html#example",
    "href": "regression.html#example",
    "title": "Regression models for describing measurements",
    "section": "Example",
    "text": "Example\nTeddy has never been in the lab and is bad at pipetting. Unfortunately, some label needed to be put in some Eppendorf tubes, and noone else was available to do it themselves or even supervise.\nEach tube had a required volume of label which Teddy tried to hit, but probably there was some inaccuracy due to bad eyesight, poor hand control or something.\nIn addition, there was also probably some consistent bias, as the pipette was consistently adding too much or too little liquid. It seemed pretty old.\nLuckily, someone was able to measure how much label ended up in 8 out of the 24 tubes with pretty good accuracy. Now we want to estimate how much label there is in the other 16 tubes, taking into account these measurements as well as what we know about the likely biased pipette and inconsistent pipetter.\nTo describe this situation we’ll first think of a regression model that describes the measurement setup, then use Python to simulate data from the model given some plausible parameter values. Next we’ll implement the model in Stan, then fit the simulated data using MCMC and then analyse the results.\n\nRegression model\nTo model the noise that Teddy introduced by being bad at pipetting and the bias introduced by the bad pipette, we need some parameters that connect the known target volumes with the unknown true volumes. Let’s call them \\(noise\\) and \\(bias\\). Since the volumes are constrained positive, a distribution that automatically excludes negative numbers is probably a good idea: the log-normal distribution is usually a good starting point. This equation describes a plausible relationship:\n\\[\nvolume \\sim LN(\\ln{(target\\cdot bias)}, noise)\n\\]\nTo model the helpful measurements, we use another log-normal distribution and assume the measuring device is unbiased and has known log-scale standard error \\(cal\\ error\\):1\n1 NB the scale parameter of a lognormal distribution represents multiplicative error\\[\nmeasurements \\sim LN(\\ln{volume}, cal\\ error)\n\\]\nTo round off the model we can think about the likely values of the unknown parameters \\(bias\\) and \\(noise\\). \\(bias\\) is likely not to be too far away from 1, otherwise someone would have probably thrown the pipette away already. A prior distribution that puts most of its mass between 0.75 and 1.25 therefore seems reasonable. Similarly, a prior for \\(noise\\) should probably not imply that Teddy’s pipetting errors regularly exceeded 30%. This consideration motivates a prior for \\(noise\\) that puts most of its mass below 0.15.\n\n\nSimulating fake data\nFirst some imports: as usual for this course we’ll be using arviz, matplotlib, cmdstanpy, pandas and numpy. stanio is a handy utility library for Stan: it is a dependency of cmdstanpy so you shouldn’t need to install it explicitly.\n\nimport arviz as az\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport stanio\n\nfrom cmdstanpy import CmdStanModel\n\nNow some hardcoded numbers, including true values for the parameters here: \\(bias\\) is 0.88 and \\(noise\\) is 0.1. Note that \\(cal\\ error\\) is much smaller than \\(bias\\).\n\nN = 24\nN_CAL = 8\nTARGET_VOLUMES = np.array(\n    [\n      *([200] * 8),\n      *([400] * 8),\n      *([800] * 8),\n    ]\n)\nMEASUREMENT_IX = np.array([1, 4, 9, 11, 15, 19, 21, 22])\nCAL_ERROR = 0.02\nBIAS_FACTOR = 0.88\nNOISE = 0.1\nRNG_SEED = 12345\n\nSimulate the true volumes\n\nrng = np.random.default_rng(seed=RNG_SEED)\nln_mean = [\n  np.log(target * BIAS_FACTOR)\n  for target in TARGET_VOLUMES\n]\nvolumes = rng.lognormal(mean=ln_mean, sigma=NOISE)\nvolumes\n\narray([152.64294349, 199.70810807, 161.32449302, 171.49715397,\n       174.67894069, 163.43175945, 153.50063823, 187.79919405,\n       364.94147086, 289.55488638, 445.13256694, 387.79655766,\n       326.2592979 , 385.23402356, 335.94110379, 349.87019831,\n       761.78380169, 620.86368119, 745.73037525, 809.71007835,\n       803.52489045, 683.21425317, 770.52360505, 598.61585552])\n\n\nPlot the volumes and the targets.\n\nf, ax = plt.subplots()\nbins = np.logspace(np.log10(100), np.log10(1000), 30)\nax.hist(volumes, bins=bins)\nfor t in (200, 400, 800):\n    ax.axvline(t, color=\"red\")\nax.semilogx()\nax.set_xticks([200, 400, 800], [200, 400, 800]);\nax.set(\n    xlabel=\"volume ($\\\\mu$l)\",\n    ylabel=\"Frequency\",\n    title=\"How much label ended up in the tubes\"\n);\n\n\n\n\n\n\n\n\nSimulate measurements for tubes in the MEASUREMENT_IX.\n\nmeasurements = [\n  rng.lognormal(np.log(vol), CAL_ERROR)\n  for vol in volumes[MEASUREMENT_IX]\n]\npd.DataFrame({\n  \"target volume\": np.array(TARGET_VOLUMES)[MEASUREMENT_IX], \n  \"actual volume\": volumes[MEASUREMENT_IX],\n  \"measured volume\": measurements\n})\n\n\n\n\n\n\n\n\n\ntarget volume\nactual volume\nmeasured volume\n\n\n\n\n0\n200\n199.708108\n199.077273\n\n\n1\n200\n174.678941\n176.256328\n\n\n2\n400\n289.554886\n281.877576\n\n\n3\n400\n387.796558\n387.163512\n\n\n4\n400\n349.870198\n362.149468\n\n\n5\n800\n809.710078\n853.238785\n\n\n6\n800\n683.214253\n693.919342\n\n\n7\n800\n770.523605\n783.399634\n\n\n\n\n\n\n\n\n\n\nWriting the model in Stan and sampling the simulated data\nI wrote up the implied statistical model in a Stan file at src/stan/ pipette.stan. This code loads this Stan file as a CmdStanModel object, checks its formatting and prints it out.\nNote that the model internally puts the data on log scale and then standardises it: this is a bit annoying but makes it way easier to set priors and can ultimately save you a lot of trouble.\n\nmodel = CmdStanModel(stan_file=\"../src/stan/pipette.stan\")\nmodel.format(overwrite_file=True, canonicalize=True)\nprint(model.code())\n\n17:47:49 - cmdstanpy - INFO - compiling stan file /Users/tedgro/repos/biosustain/bayesian_statistics_for_computational_biology/src/stan/pipette.stan to exe file /Users/tedgro/repos/biosustain/bayesian_statistics_for_computational_biology/src/stan/pipette\n17:47:53 - cmdstanpy - INFO - compiled model executable: /Users/tedgro/repos/biosustain/bayesian_statistics_for_computational_biology/src/stan/pipette\n\n\nfunctions {\n  vector standardise(vector v, real m, real s) {\n    return (v - m) / s;\n  }\n  real standardise(real v, real m, real s) {\n    return (v - m) / s;\n  }\n  vector unstandardise(vector u, real m, real s) {\n    return m + u * s;\n  }\n  real unstandardise(real u, real m, real s) {\n    return m + u * s;\n  }\n}\ndata {\n  int&lt;lower=1&gt; N;\n  int&lt;lower=0&gt; N_cal;\n  vector&lt;lower=0&gt;[N] target_volume;\n  vector&lt;lower=0&gt;[N_cal] y;\n  array[N_cal] int&lt;lower=1, upper=N&gt; measurement_ix;\n  real&lt;lower=0&gt; cal_error;\n  int&lt;lower=0, upper=1&gt; likelihood;\n}\ntransformed data {\n  vector[N_cal] y_ls = standardise(log(y), mean(log(y)), sd(log(y)));\n  vector[N] target_volume_ls = standardise(log(target_volume), mean(log(y)),\n                                           sd(log(y)));\n  real cal_error_s = cal_error / sd(log(y));\n}\nparameters {\n  real&lt;lower=0&gt; volume_noise_s;\n  real bias_factor_l;\n  vector[N] volume_ls;\n}\nmodel {\n  volume_noise_s ~ lognormal(log(0.1), 0.5);\n  bias_factor_l ~ normal(0, 0.15);\n  volume_ls ~ normal(target_volume_ls + bias_factor_l, volume_noise_s);\n  if (likelihood) {\n    for (i in 1 : N_cal) {\n      y_ls[i] ~ normal(volume_ls[measurement_ix[i]], cal_error_s);\n    }\n  }\n}\ngenerated quantities {\n  real bias_factor = exp(bias_factor_l);\n  real volume_noise = volume_noise_s * sd(log(y));\n  vector[N] volume = exp(unstandardise(volume_ls, mean(log(y)), sd(log(y))));\n  vector[N_cal] y_rep;\n  vector[N_cal] llik;\n  for (i in 1 : N_cal) {\n    int ms_ix = measurement_ix[i];\n    y_rep[i] = lognormal_rng(log(volume[ms_ix]), cal_error);\n    llik[i] = lognormal_lpdf(y[i] | log(volume[ms_ix]), cal_error);\n  }\n}\n\n\n\n\nThis code loads some data into a dictionary that is compatible with Stan and carries out two MCMC runs, one in prior mode and one in posterior mode.\n\nstan_input_posterior = stanio.json.process_dictionary(\n    {\n      \"N\": N,\n      \"N_cal\": N_CAL,\n      \"target_volume\": TARGET_VOLUMES,\n      \"y\": measurements,\n      \"measurement_ix\": MEASUREMENT_IX + 1,\n      \"cal_error\": CAL_ERROR,\n      \"likelihood\": 1,\n  }\n)\nstan_input_prior = stan_input_posterior | {\"likelihood\": 0}\nmcmc_prior = model.sample(\n    data=stan_input_prior,\n    adapt_delta=0.999,\n    max_treedepth=12,\n    seed=RNG_SEED,\n)\nmcmc_posterior = model.sample(data=stan_input_posterior, seed=RNG_SEED)\nmcmc_prior.diagnose()\nmcmc_posterior.diagnose()\n\n17:47:53 - cmdstanpy - INFO - CmdStan start processing\n17:47:54 - cmdstanpy - INFO - CmdStan done processing.\n17:47:54 - cmdstanpy - INFO - CmdStan start processing\n17:47:54 - cmdstanpy - INFO - CmdStan done processing.\n17:47:54 - cmdstanpy - WARNING - Non-fatal error during sampling:\nException: normal_lpdf: Scale parameter is 0, but must be positive! (in 'pipette.stan', line 38, column 2 to column 71)\nException: normal_lpdf: Scale parameter is 0, but must be positive! (in 'pipette.stan', line 38, column 2 to column 71)\nException: normal_lpdf: Scale parameter is 0, but must be positive! (in 'pipette.stan', line 38, column 2 to column 71)\nException: normal_lpdf: Scale parameter is 0, but must be positive! (in 'pipette.stan', line 38, column 2 to column 71)\nConsider re-running with show_console=True if the above output is unclear!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                                                                                                                                                                                                                                                                                \n                                                                                                                                                                                                                                                                                                                                \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'Processing csv files: /var/folders/ql/z_6fb5792v1_8tscf4hg5byc0000gp/T/tmp4awnnrlb/pipette5njaoulk/pipette-20240412174754_1.csv, /var/folders/ql/z_6fb5792v1_8tscf4hg5byc0000gp/T/tmp4awnnrlb/pipette5njaoulk/pipette-20240412174754_2.csv, /var/folders/ql/z_6fb5792v1_8tscf4hg5byc0000gp/T/tmp4awnnrlb/pipette5njaoulk/pipette-20240412174754_3.csv, /var/folders/ql/z_6fb5792v1_8tscf4hg5byc0000gp/T/tmp4awnnrlb/pipette5njaoulk/pipette-20240412174754_4.csv\\n\\nChecking sampler transitions treedepth.\\nTreedepth satisfactory for all transitions.\\n\\nChecking sampler transitions for divergences.\\nNo divergent transitions found.\\n\\nChecking E-BFMI - sampler transitions HMC potential energy.\\nE-BFMI satisfactory.\\n\\nEffective sample size satisfactory.\\n\\nSplit R-hat values satisfactory all parameters.\\n\\nProcessing complete, no problems detected.\\n'\n\n\nThe diagnostics seem ok, though interestingly the prior was pretty tricky to sample accurately.\n\n\nLoading the MCMC results with arviz\nThis code loads both MCMC runs into an arviz InferenceData object.\n\ncoords = {\"obs\": MEASUREMENT_IX, \"tube\": range(N)}\ndims={\n    \"y\": [\"obs\"],\n    \"y_rep\": [\"obs\"],\n    \"target_volume\": [\"tube\"],\n    \"true_volume\": [\"tube\"],\n    \"volume\": [\"tube\"],\n    \"tube\": [\"tube\"]\n}\nidata = az.from_cmdstanpy(\n    posterior=mcmc_posterior,\n    prior=mcmc_prior,\n    log_likelihood=\"llik\",\n    observed_data=stan_input_posterior | {\n        \"true_volume\": volumes, \"tube\": range(N)\n    },\n    posterior_predictive={\"y\": \"y_rep\"},\n    coords=coords,\n    dims=dims\n)\nidata\n\n\n            \n              \n                arviz.InferenceData\n              \n              \n              \n            \n                  \n                  posterior\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 2MB\nDimensions:          (chain: 4, draw: 1000, volume_ls_dim_0: 24, tube: 24)\nCoordinates:\n  * chain            (chain) int64 32B 0 1 2 3\n  * draw             (draw) int64 8kB 0 1 2 3 4 5 6 ... 994 995 996 997 998 999\n  * volume_ls_dim_0  (volume_ls_dim_0) int64 192B 0 1 2 3 4 5 ... 19 20 21 22 23\n  * tube             (tube) int64 192B 0 1 2 3 4 5 6 7 ... 17 18 19 20 21 22 23\nData variables:\n    volume_noise_s   (chain, draw) float64 32kB 0.149 0.2378 ... 0.1396 0.1959\n    bias_factor_l    (chain, draw) float64 32kB -0.2014 -0.07906 ... -0.07839\n    volume_ls        (chain, draw, volume_ls_dim_0) float64 768kB -1.275 ... ...\n    bias_factor      (chain, draw) float64 32kB 0.8176 0.924 ... 0.9842 0.9246\n    volume_noise     (chain, draw) float64 32kB 0.09116 0.1455 ... 0.1199\n    volume           (chain, draw, tube) float64 768kB 182.9 192.1 ... 855.2\nAttributes:\n    created_at:                 2024-04-12T15:47:54.874792\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000volume_ls_dim_0: 24tube: 24Coordinates: (4)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])volume_ls_dim_0(volume_ls_dim_0)int640 1 2 3 4 5 6 ... 18 19 20 21 22 23array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23])tube(tube)int640 1 2 3 4 5 6 ... 18 19 20 21 22 23array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23])Data variables: (6)volume_noise_s(chain, draw)float640.149 0.2378 ... 0.1396 0.1959array([[0.148979, 0.237794, 0.122436, ..., 0.140801, 0.178431, 0.198993],\n       [0.158124, 0.141742, 0.157009, ..., 0.167521, 0.137968, 0.115493],\n       [0.168817, 0.188685, 0.138985, ..., 0.138549, 0.116906, 0.133163],\n       [0.151583, 0.148293, 0.18479 , ..., 0.158791, 0.139599, 0.195866]])bias_factor_l(chain, draw)float64-0.2014 -0.07906 ... -0.07839array([[-0.201351 , -0.0790569, -0.105641 , ..., -0.123153 , -0.0710773,\n        -0.0700885],\n       [-0.0982885, -0.0746649, -0.0754556, ..., -0.128265 , -0.163382 ,\n        -0.123952 ],\n       [ 0.0213591, -0.182919 , -0.17903  , ..., -0.134593 , -0.132122 ,\n        -0.131316 ],\n       [-0.0805919, -0.0926586, -0.117743 , ..., -0.190522 , -0.0158839,\n        -0.0783902]])volume_ls(chain, draw, volume_ls_dim_0)float64-1.275 -1.194 ... 1.099 1.246array([[[-1.2747  , -1.19448 , -1.22282 , ...,  0.879734,  1.03417 ,\n          0.762953],\n        [-1.40687 , -1.09754 , -1.14365 , ...,  0.936603,  1.15697 ,\n          0.907036],\n        [-0.935161, -1.16238 , -1.13239 , ...,  0.901988,  1.09336 ,\n          1.1396  ],\n        ...,\n        [-1.38442 , -1.08361 , -1.21375 , ...,  0.945476,  1.12959 ,\n          1.01907 ],\n        [-1.03524 , -1.11487 , -0.966034, ...,  0.964533,  1.11521 ,\n          1.0335  ],\n        [-1.29565 , -1.14228 , -1.38558 , ...,  0.843054,  1.08359 ,\n          1.15616 ]],\n\n       [[-1.28813 , -1.15007 , -1.30488 , ...,  0.863103,  1.06637 ,\n          1.34264 ],\n        [-1.17917 , -1.1655  , -1.16521 , ...,  0.874006,  1.07137 ,\n          1.25143 ],\n        [-1.20124 , -1.14406 , -1.0035  , ...,  0.908254,  1.06948 ,\n          1.04256 ],\n...\n        [-1.28454 , -1.16143 , -1.07814 , ...,  0.871924,  1.07582 ,\n          1.04087 ],\n        [-1.35706 , -1.15124 , -1.11947 , ...,  0.87177 ,  1.04045 ,\n          0.944458],\n        [-1.23871 , -1.14033 , -1.48308 , ...,  0.895505,  1.1146  ,\n          0.996843]],\n\n       [[-1.21437 , -1.11281 , -1.31588 , ...,  0.869607,  1.11421 ,\n          0.911445],\n        [-1.23622 , -1.12363 , -1.30974 , ...,  0.940612,  1.11077 ,\n          1.07039 ],\n        [-1.15205 , -1.14246 , -1.21216 , ...,  0.914147,  1.09383 ,\n          1.10271 ],\n        ...,\n        [-1.28744 , -1.10417 , -1.22327 , ...,  0.90872 ,  1.1949  ,\n          1.00884 ],\n        [-1.19644 , -1.16323 , -1.25646 , ...,  0.913467,  1.0723  ,\n          1.06841 ],\n        [-0.985007, -1.08883 , -1.03812 , ...,  0.941881,  1.09928 ,\n          1.24558 ]]])bias_factor(chain, draw)float640.8176 0.924 ... 0.9842 0.9246array([[0.817625, 0.923987, 0.899748, ..., 0.884128, 0.93139 , 0.932311],\n       [0.906387, 0.928054, 0.927321, ..., 0.87962 , 0.849267, 0.883422],\n       [1.02159 , 0.832835, 0.836081, ..., 0.874071, 0.876234, 0.876941],\n       [0.92257 , 0.911505, 0.888924, ..., 0.826528, 0.984242, 0.924604]])volume_noise(chain, draw)float640.09116 0.1455 ... 0.08542 0.1199array([[0.0911635, 0.145511 , 0.0749212, ..., 0.0861592, 0.109185 ,\n        0.121768 ],\n       [0.0967594, 0.0867349, 0.0960768, ..., 0.102509 , 0.0844255,\n        0.0706728],\n       [0.103303 , 0.11546  , 0.0850475, ..., 0.0847808, 0.0715373,\n        0.0814854],\n       [0.092757 , 0.0907435, 0.113077 , ..., 0.0971674, 0.0854233,\n        0.119854 ]])volume(chain, draw, tube)float64182.9 192.1 188.8 ... 782.0 855.2array([[[182.932, 192.136, 188.833, ..., 683.658, 751.418, 636.508],\n        [168.719, 203.878, 198.206, ..., 707.868, 810.057, 695.176],\n        [225.177, 195.948, 199.577, ..., 693.032, 779.132, 801.494],\n        ...,\n        [171.054, 205.624, 189.884, ..., 711.722, 796.6  , 744.505],\n        [211.801, 201.728, 220.963, ..., 720.07 , 789.621, 751.109],\n        [180.602, 198.373, 170.932, ..., 668.484, 774.49 , 809.654]],\n\n       [[181.435, 197.428, 179.585, ..., 676.736, 766.367, 907.524],\n        [193.944, 195.574, 195.609, ..., 681.266, 768.718, 858.258],\n        [191.343, 198.157, 215.955, ..., 695.694, 767.829, 755.286],\n        ...,\n        [179.235, 204.075, 162.611, ..., 709.551, 781.422, 723.426],\n        [189.975, 192.176, 176.443, ..., 714.348, 760.103, 754.809],\n        [186.767, 198.987, 204.561, ..., 705.813, 787.317, 706.511]],\n\n       [[198.651, 208.316, 215.697, ..., 682.152, 770.541, 821.472],\n        [175.866, 190.675, 167.71 , ..., 713.088, 788.866, 644.97 ],\n        [185.411, 195.48 , 169.569, ..., 690.813, 788.233, 665.731],\n        ...,\n        [181.834, 196.062, 206.313, ..., 680.399, 770.813, 754.506],\n        [173.941, 197.288, 201.161, ..., 680.335, 754.311, 711.279],\n        [187.005, 198.61 , 161.032, ..., 690.288, 789.322, 734.448]],\n\n       [[189.812, 201.983, 178.38 , ..., 679.435, 789.135, 697.054],\n        [187.291, 200.65 , 179.052, ..., 709.606, 787.476, 768.257],\n        [197.19 , 198.351, 190.069, ..., 698.207, 779.357, 783.604],\n        ...,\n        [181.511, 203.053, 188.781, ..., 695.893, 829.077, 739.861],\n        [191.905, 195.846, 184.986, ..., 697.917, 769.157, 767.329],\n        [218.412, 204.968, 211.428, ..., 710.158, 781.96 , 855.193]]])Indexes: (4)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))volume_ls_dim_0PandasIndexPandasIndex(Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23],\n      dtype='int64', name='volume_ls_dim_0'))tubePandasIndexPandasIndex(Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23],\n      dtype='int64', name='tube'))Attributes: (4)created_at :2024-04-12T15:47:54.874792arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  posterior_predictive\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 264kB\nDimensions:  (chain: 4, draw: 1000, obs: 8)\nCoordinates:\n  * chain    (chain) int64 32B 0 1 2 3\n  * draw     (draw) int64 8kB 0 1 2 3 4 5 6 7 ... 993 994 995 996 997 998 999\n  * obs      (obs) int64 64B 1 4 9 11 15 19 21 22\nData variables:\n    y_rep    (chain, draw, obs) float64 256kB 197.1 177.7 290.6 ... 693.9 779.7\nAttributes:\n    created_at:                 2024-04-12T15:47:54.879440\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000obs: 8Coordinates: (3)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])obs(obs)int641 4 9 11 15 19 21 22array([ 1,  4,  9, 11, 15, 19, 21, 22])Data variables: (1)y_rep(chain, draw, obs)float64197.1 177.7 290.6 ... 693.9 779.7array([[[197.116, 177.676, 290.624, ..., 817.525, 684.834, 768.599],\n        [207.123, 178.881, 276.029, ..., 837.783, 707.797, 799.808],\n        [193.412, 176.359, 312.075, ..., 779.207, 670.578, 748.349],\n        ...,\n        [205.396, 181.619, 282.37 , ..., 823.026, 693.464, 776.76 ],\n        [196.261, 179.431, 277.182, ..., 842.408, 693.157, 799.594],\n        [194.616, 187.719, 282.712, ..., 827.156, 681.762, 760.655]],\n\n       [[194.801, 174.147, 275.591, ..., 837.393, 662.098, 793.396],\n        [196.473, 175.265, 281.09 , ..., 849.397, 685.798, 799.947],\n        [188.093, 169.629, 275.093, ..., 851.105, 699.691, 758.693],\n        ...,\n        [199.97 , 181.119, 276.119, ..., 885.826, 721.481, 780.279],\n        [190.317, 177.701, 271.189, ..., 838.828, 746.589, 728.727],\n        [204.84 , 172.027, 285.739, ..., 834.172, 716.608, 793.402]],\n\n       [[208.713, 177.249, 294.043, ..., 808.862, 703.655, 795.465],\n        [195.615, 175.848, 270.427, ..., 868.339, 708.692, 818.016],\n        [196.822, 173.831, 290.472, ..., 826.401, 681.787, 797.722],\n        ...,\n        [193.524, 174.954, 287.664, ..., 903.736, 662.875, 770.548],\n        [198.162, 176.923, 293.263, ..., 855.101, 686.138, 768.147],\n        [195.309, 174.313, 283.913, ..., 858.254, 697.01 , 809.608]],\n\n       [[206.681, 178.897, 283.43 , ..., 877.47 , 671.592, 773.122],\n        [204.176, 182.882, 273.709, ..., 802.932, 712.307, 766.771],\n        [198.835, 175.814, 295.483, ..., 807.124, 708.253, 755.885],\n        ...,\n        [199.387, 166.869, 282.976, ..., 836.791, 687.756, 831.191],\n        [189.255, 178.416, 288.503, ..., 861.03 , 712.108, 784.301],\n        [207.587, 184.839, 288.502, ..., 839.977, 693.941, 779.685]]])Indexes: (3)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))obsPandasIndexPandasIndex(Index([1, 4, 9, 11, 15, 19, 21, 22], dtype='int64', name='obs'))Attributes: (4)created_at :2024-04-12T15:47:54.879440arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  log_likelihood\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 264kB\nDimensions:     (chain: 4, draw: 1000, llik_dim_0: 8)\nCoordinates:\n  * chain       (chain) int64 32B 0 1 2 3\n  * draw        (draw) int64 8kB 0 1 2 3 4 5 6 7 ... 993 994 995 996 997 998 999\n  * llik_dim_0  (llik_dim_0) int64 64B 0 1 2 3 4 5 6 7\nData variables:\n    llik        (chain, draw, llik_dim_0) float64 256kB -3.875 -2.193 ... -3.675\nAttributes:\n    created_at:                 2024-04-12T15:47:54.921448\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000llik_dim_0: 8Coordinates: (3)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])llik_dim_0(llik_dim_0)int640 1 2 3 4 5 6 7array([0, 1, 2, 3, 4, 5, 6, 7])Data variables: (1)llik(chain, draw, llik_dim_0)float64-3.875 -2.193 ... -4.218 -3.675array([[[-3.87496, -2.19298, -5.05717, ..., -4.10576, -3.82668,\n         -5.84213],\n        [-3.0104 , -2.18047, -2.95307, ..., -3.76203, -4.04436,\n         -5.07012],\n        [-2.61437, -2.19405, -4.63408, ..., -3.87112, -3.55132,\n         -3.70786],\n        ...,\n        [-3.60909, -2.48505, -2.6706 , ..., -3.91375, -4.35139,\n         -4.01956],\n        [-2.51933, -2.83159, -2.7908 , ..., -3.79013, -5.25984,\n         -3.74878],\n        [-2.31632, -4.73471, -3.46818, ..., -5.85992, -5.29236,\n         -3.8341 ]],\n\n       [[-2.38707, -2.3283 , -2.64878, ..., -3.83624, -4.33519,\n         -4.27453],\n        [-2.69467, -2.22771, -2.68636, ..., -3.96266, -3.97258,\n         -4.11793],\n        [-2.32746, -2.27031, -4.41154, ..., -4.53482, -3.55743,\n         -4.17434],\n...\n        [-2.59181, -2.25385, -2.67099, ..., -4.91015, -4.03322,\n         -3.99848],\n        [-2.40251, -2.43096, -4.67866, ..., -4.25938, -4.03786,\n         -5.46025],\n        [-2.30753, -3.00209, -2.83217, ..., -3.75844, -3.58368,\n         -3.74147]],\n\n       [[-2.56303, -2.25859, -3.31605, ..., -3.90128, -4.10547,\n         -3.73708],\n        [-2.37797, -2.74359, -4.55847, ..., -4.38751, -4.17394,\n         -3.70423],\n        [-2.31732, -2.66832, -4.37736, ..., -3.80292, -3.59671,\n         -3.70401],\n        ...,\n        [-2.78946, -2.22266, -2.67603, ..., -3.75926, -3.55935,\n         -7.68485],\n        [-2.63537, -2.2518 , -3.67463, ..., -4.03551, -3.59052,\n         -4.09134],\n        [-3.36342, -2.82215, -3.077  , ..., -3.84831, -4.21812,\n         -3.67479]]])Indexes: (3)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))llik_dim_0PandasIndexPandasIndex(Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64', name='llik_dim_0'))Attributes: (4)created_at :2024-04-12T15:47:54.921448arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  sample_stats\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 204kB\nDimensions:          (chain: 4, draw: 1000)\nCoordinates:\n  * chain            (chain) int64 32B 0 1 2 3\n  * draw             (draw) int64 8kB 0 1 2 3 4 5 6 ... 994 995 996 997 998 999\nData variables:\n    lp               (chain, draw) float64 32kB 21.01 18.71 ... 24.94 22.19\n    acceptance_rate  (chain, draw) float64 32kB 0.9988 0.7904 ... 0.8739 0.9229\n    step_size        (chain, draw) float64 32kB 0.3503 0.3503 ... 0.4368 0.4368\n    tree_depth       (chain, draw) int64 32kB 3 4 3 3 3 3 3 3 ... 3 3 3 3 3 3 4\n    n_steps          (chain, draw) int64 32kB 7 31 7 15 7 7 7 ... 7 7 7 7 7 7 15\n    diverging        (chain, draw) bool 4kB False False False ... False False\n    energy           (chain, draw) float64 32kB -6.192 -8.972 ... -15.39 -11.6\nAttributes:\n    created_at:                 2024-04-12T15:47:54.877966\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000Coordinates: (2)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])Data variables: (7)lp(chain, draw)float6421.01 18.71 28.67 ... 24.94 22.19array([[21.009 , 18.71  , 28.6744, ..., 24.9497, 21.3791, 18.4294],\n       [27.8086, 32.2878, 26.6081, ..., 26.1025, 28.0347, 28.8471],\n       [24.4864, 25.8458, 31.4533, ..., 31.4475, 30.7953, 30.7299],\n       [30.3395, 21.0069, 20.8335, ..., 24.7186, 24.9444, 22.194 ]])acceptance_rate(chain, draw)float640.9988 0.7904 1.0 ... 0.8739 0.9229array([[0.998827, 0.790351, 1.      , ..., 0.935358, 0.971577, 0.847244],\n       [0.979632, 0.984735, 0.751846, ..., 1.      , 0.901231, 0.83027 ],\n       [0.64411 , 0.901806, 0.983725, ..., 0.809004, 0.692338, 0.828195],\n       [0.931977, 0.618653, 0.940008, ..., 0.973274, 0.873885, 0.922928]])step_size(chain, draw)float640.3503 0.3503 ... 0.4368 0.4368array([[0.350264, 0.350264, 0.350264, ..., 0.350264, 0.350264, 0.350264],\n       [0.343679, 0.343679, 0.343679, ..., 0.343679, 0.343679, 0.343679],\n       [0.326612, 0.326612, 0.326612, ..., 0.326612, 0.326612, 0.326612],\n       [0.43677 , 0.43677 , 0.43677 , ..., 0.43677 , 0.43677 , 0.43677 ]])tree_depth(chain, draw)int643 4 3 3 3 3 3 3 ... 3 3 3 3 3 3 3 4array([[3, 4, 3, ..., 4, 4, 4],\n       [3, 3, 4, ..., 4, 4, 3],\n       [4, 4, 4, ..., 3, 4, 3],\n       [3, 3, 3, ..., 3, 3, 4]])n_steps(chain, draw)int647 31 7 15 7 7 7 ... 7 7 7 7 7 7 15array([[ 7, 31,  7, ..., 15, 15, 15],\n       [ 7,  7, 15, ..., 15, 31,  7],\n       [15, 15, 15, ...,  7, 15, 15],\n       [ 7,  7,  7, ...,  7,  7, 15]])diverging(chain, draw)boolFalse False False ... False Falsearray([[False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False]])energy(chain, draw)float64-6.192 -8.972 ... -15.39 -11.6array([[ -6.19192,  -8.97176, -14.139  , ..., -11.2611 , -12.0468 ,\n         -1.39412],\n       [-13.6371 , -23.0408 , -15.4574 , ...,  -7.31748, -10.7674 ,\n        -13.1799 ],\n       [-14.2463 , -12.2545 , -20.9744 , ..., -15.1772 , -12.6979 ,\n        -18.2411 ],\n       [-17.2553 , -11.9235 ,  -9.46781, ..., -16.5739 , -15.3934 ,\n        -11.6042 ]])Indexes: (2)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))Attributes: (4)created_at :2024-04-12T15:47:54.877966arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  prior\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 2MB\nDimensions:          (chain: 4, draw: 1000, volume_ls_dim_0: 24, tube: 24,\n                      obs: 8, llik_dim_0: 8)\nCoordinates:\n  * chain            (chain) int64 32B 0 1 2 3\n  * draw             (draw) int64 8kB 0 1 2 3 4 5 6 ... 994 995 996 997 998 999\n  * volume_ls_dim_0  (volume_ls_dim_0) int64 192B 0 1 2 3 4 5 ... 19 20 21 22 23\n  * tube             (tube) int64 192B 0 1 2 3 4 5 6 7 ... 17 18 19 20 21 22 23\n  * obs              (obs) int64 64B 1 4 9 11 15 19 21 22\n  * llik_dim_0       (llik_dim_0) int64 64B 0 1 2 3 4 5 6 7\nData variables:\n    volume_noise_s   (chain, draw) float64 32kB 0.02974 0.02728 ... 0.2746\n    bias_factor_l    (chain, draw) float64 32kB -0.1025 -0.07485 ... -0.1921\n    volume_ls        (chain, draw, volume_ls_dim_0) float64 768kB -1.18 ... 0...\n    bias_factor      (chain, draw) float64 32kB 0.9026 0.9279 ... 0.9219 0.8252\n    volume_noise     (chain, draw) float64 32kB 0.0182 0.01669 ... 0.1236 0.168\n    volume           (chain, draw, tube) float64 768kB 193.8 185.0 ... 693.1\n    y_rep            (chain, draw, obs) float64 256kB 184.8 189.1 ... 1.002e+03\n    llik             (chain, draw, llik_dim_0) float64 256kB -8.981 ... -87.32\nAttributes:\n    created_at:                 2024-04-12T15:47:54.915558\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000volume_ls_dim_0: 24tube: 24obs: 8llik_dim_0: 8Coordinates: (6)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])volume_ls_dim_0(volume_ls_dim_0)int640 1 2 3 4 5 6 ... 18 19 20 21 22 23array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23])tube(tube)int640 1 2 3 4 5 6 ... 18 19 20 21 22 23array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23])obs(obs)int641 4 9 11 15 19 21 22array([ 1,  4,  9, 11, 15, 19, 21, 22])llik_dim_0(llik_dim_0)int640 1 2 3 4 5 6 7array([0, 1, 2, 3, 4, 5, 6, 7])Data variables: (8)volume_noise_s(chain, draw)float640.02974 0.02728 ... 0.2021 0.2746array([[0.0297445, 0.0272758, 0.0265095, ..., 0.178736 , 0.192878 ,\n        0.143125 ],\n       [0.0217743, 0.0275153, 0.0318496, ..., 0.187067 , 0.213967 ,\n        0.2151   ],\n       [0.14644  , 0.161344 , 0.154124 , ..., 0.222906 , 0.210747 ,\n        0.183849 ],\n       [0.196802 , 0.224444 , 0.332829 , ..., 0.104148 , 0.202053 ,\n        0.274571 ]])bias_factor_l(chain, draw)float64-0.1025 -0.07485 ... -0.1921array([[-0.102507 , -0.074851 , -0.071183 , ..., -0.0135833, -0.072937 ,\n        -0.0888987],\n       [-0.131403 , -0.137815 , -0.131853 , ..., -0.0773899,  0.0578722,\n        -0.0226735],\n       [ 0.134711 ,  0.0641626, -0.0368078, ..., -0.277545 , -0.22355  ,\n        -0.29311  ],\n       [-0.0320055, -0.127452 ,  0.0724585, ..., -0.0552708, -0.0813462,\n        -0.192088 ]])volume_ls(chain, draw, volume_ls_dim_0)float64-1.18 -1.256 ... 1.525 0.9022array([[[-1.18014 , -1.25596 , -1.21539 , ...,  1.06275 ,  1.04836 ,\n          1.03579 ],\n        [-1.24896 , -1.18338 , -1.21905 , ...,  1.03778 ,  1.05845 ,\n          1.05922 ],\n        [-1.18062 , -1.20861 , -1.20187 , ...,  1.06469 ,  1.05634 ,\n          1.01356 ],\n        ...,\n        [-1.06469 , -1.19225 , -1.39826 , ...,  0.878588,  1.39824 ,\n          1.34754 ],\n        [-1.43398 , -1.40853 , -1.21943 , ...,  1.50548 ,  0.928725,\n          0.986833],\n        [-1.19609 , -1.28651 , -1.26602 , ...,  0.972567,  1.07923 ,\n          1.10071 ]],\n\n       [[-1.24692 , -1.24356 , -1.21965 , ...,  1.00025 ,  0.983762,\n          1.02885 ],\n        [-1.28328 , -1.29047 , -1.25435 , ...,  1.07908 ,  0.979001,\n          0.99518 ],\n        [-1.24983 , -1.2417  , -1.28149 , ...,  0.913942,  1.01969 ,\n          1.0017  ],\n...\n        [-1.28413 , -1.1961  , -1.73514 , ...,  1.07113 ,  1.08167 ,\n          0.796746],\n        [-1.53629 , -1.42865 , -1.07195 , ...,  0.73767 ,  0.848461,\n          1.2325  ],\n        [-1.33974 , -1.18125 , -1.43554 , ...,  0.932523,  0.996232,\n          0.864258]],\n\n       [[-1.04915 , -0.949361, -0.929134, ...,  1.15517 ,  0.924563,\n          0.388474],\n        [-1.26699 , -1.06466 , -1.12933 , ...,  0.873924,  0.755863,\n          1.21534 ],\n        [-1.1652  , -1.53275 , -1.46456 , ...,  1.52952 ,  1.5088  ,\n          1.27139 ],\n        ...,\n        [-1.14013 , -1.28078 , -1.14028 , ...,  1.01727 ,  1.10426 ,\n          0.960508],\n        [-1.4791  , -1.09886 , -1.39305 , ...,  0.918405,  1.08038 ,\n          1.22328 ],\n        [-1.2026  , -1.02384 , -1.02024 , ...,  1.01766 ,  1.52503 ,\n          0.902215]]])bias_factor(chain, draw)float640.9026 0.9279 ... 0.9219 0.8252array([[0.902572, 0.927882, 0.931291, ..., 0.986509, 0.929659, 0.914938],\n       [0.876865, 0.87126 , 0.87647 , ..., 0.925529, 1.05958 , 0.977582],\n       [1.14421 , 1.06627 , 0.963861, ..., 0.757641, 0.799675, 0.74594 ],\n       [0.968501, 0.880336, 1.07515 , ..., 0.946229, 0.921874, 0.825234]])volume_noise(chain, draw)float640.0182 0.01669 ... 0.1236 0.168array([[0.0182013, 0.0166906, 0.0162217, ..., 0.109372 , 0.118026 ,\n        0.0875808],\n       [0.0133241, 0.0168372, 0.0194894, ..., 0.11447  , 0.130931 ,\n        0.131624 ],\n       [0.0896095, 0.0987295, 0.0943116, ..., 0.136401 , 0.12896  ,\n        0.112501 ],\n       [0.120427 , 0.137342 , 0.203665 , ..., 0.0637301, 0.12364  ,\n        0.168016 ]])volume(chain, draw, tube)float64193.8 185.0 ... 1.015e+03 693.1array([[[ 193.83 ,  185.043,  189.693, ...,  764.673,  757.97 ,\n          752.164],\n        [ 185.837,  193.446,  189.27 , ...,  753.078,  762.666,\n          763.023],\n        [ 193.772,  190.482,  191.27 , ...,  765.581,  761.682,\n          742.002],\n        ...,\n        [ 208.018,  192.399,  169.611, ...,  683.179,  938.933,\n          910.251],\n        [ 165.943,  168.549,  189.225, ..., 1002.61 ,  704.464,\n          729.963],\n        [ 191.947,  181.615,  183.906, ...,  723.619,  772.422,\n          782.645]],\n\n       [[ 186.069,  186.452,  189.2  , ...,  735.982,  728.593,\n          748.973],\n        [ 181.974,  181.175,  185.225, ...,  772.355,  726.473,\n          733.701],\n        [ 185.738,  186.664,  182.174, ...,  698.12 ,  744.787,\n          736.633],\n...\n        [ 181.879,  191.946,  138.015, ...,  768.607,  773.58 ,\n          649.808],\n        [ 155.873,  166.485,  207.096, ...,  626.737,  670.7  ,\n          848.373],\n        [ 175.795,  193.698,  165.786, ...,  706.103,  734.174,\n          677.215]],\n\n       [[ 210.005,  223.229,  226.009, ...,  809.167,  702.672,\n          506.157],\n        [ 183.797,  208.022,  199.951, ...,  681.232,  633.753,\n          839.513],\n        [ 195.61 ,  156.211,  162.867, ..., 1017.47 , 1004.65 ,\n          868.806],\n        ...,\n        [ 198.634,  182.253,  198.615, ...,  743.688,  784.348,\n          718.299],\n        [ 161.425,  203.714,  170.153, ...,  700.029,  772.966,\n          843.605],\n        [ 191.183,  213.283,  213.753, ...,  743.862, 1014.68 ,\n          693.128]]])y_rep(chain, draw, obs)float64184.8 189.1 ... 741.0 1.002e+03array([[[ 184.813,  189.054,  386.057, ...,  759.48 ,  754.107,\n          752.463],\n        [ 188.057,  194.853,  377.611, ...,  747.653,  741.944,\n          791.905],\n        [ 191.471,  191.019,  380.344, ...,  762.074,  750.234,\n          764.223],\n        ...,\n        [ 188.237,  217.168,  422.702, ...,  804.179,  687.31 ,\n          936.802],\n        [ 167.074,  207.593,  425.475, ...,  681.052, 1021.48 ,\n          705.951],\n        [ 177.321,  174.68 ,  365.093, ...,  756.83 ,  745.255,\n          747.625]],\n\n       [[ 194.119,  186.317,  365.097, ...,  722.354,  724.962,\n          745.609],\n        [ 183.759,  188.886,  368.915, ...,  750.265,  771.006,\n          708.641],\n        [ 188.523,  182.887,  388.006, ...,  759.472,  700.728,\n          735.546],\n...\n        [ 187.093,  217.335,  268.847, ...,  600.192,  760.567,\n          755.355],\n        [ 165.12 ,  131.573,  447.16 , ...,  730.651,  634.832,\n          670.844],\n        [ 194.342,  155.376,  278.762, ...,  557.058,  670.72 ,\n          756.81 ]],\n\n       [[ 227.482,  215.861,  369.136, ...,  876.322,  807.167,\n          691.492],\n        [ 204.28 ,  253.91 ,  468.703, ...,  851.316,  673.234,\n          629.031],\n        [ 158.707,  185.01 ,  421.974, ..., 1219.31 , 1041.13 ,\n          994.95 ],\n        ...,\n        [ 181.02 ,  216.746,  403.83 , ...,  735.791,  757.416,\n          787.206],\n        [ 204.988,  169.965,  321.8  , ...,  875.623,  693.14 ,\n          777.141],\n        [ 215.283,  205.664,  494.475, ...,  677.682,  740.974,\n         1001.79 ]]])llik(chain, draw, llik_dim_0)float64-8.981 -8.16 ... -9.587 -87.32array([[[  -8.98149,   -8.16041, -121.834  , ...,  -26.6511 ,\n          -15.333  ,   -5.03173],\n        [  -3.3298 ,   -6.74602, -120.175  , ...,  -18.3798 ,\n          -11.9159 ,   -4.56985],\n        [  -4.73572,  -11.8407 , -113.21   , ...,  -18.8408 ,\n          -15.6229 ,   -4.65854],\n        ...,\n        [  -3.75606,  -57.2464 , -186.1    , ...,   -4.7875 ,\n           -3.85341,  -44.6675 ],\n        [ -36.9401 ,  -34.6153 , -209.275  , ...,  -58.3687 ,\n         -172.836  ,  -17.7702 ],\n        [ -12.8355 ,   -2.24944,  -85.4265 , ...,  -17.943  ,\n           -5.74474,   -3.91947]],\n\n       [[  -7.66673,   -5.33243,  -94.05   , ...,  -33.5105 ,\n           -7.87838,  -10.2459 ],\n        [ -13.3995 ,   -6.43127,  -83.7495 , ...,  -37.2591 ,\n          -17.8842 ,  -10.7848 ],\n        [  -7.4818 ,   -3.62121,  -98.3658 , ...,  -24.9407 ,\n           -3.5948 ,   -6.86394],\n...\n        [  -3.96411,  -65.3276 ,   -6.23833, ..., -161.946  ,\n          -16.6114 ,   -3.86945],\n        [ -42.2559 ,  -75.7815 , -300.021  , ...,  -44.6827 ,\n          -16.5108 ,  -33.8265 ],\n        [  -3.23865,  -16.1718 ,   -4.7924 , ..., -249.053  ,\n           -3.92796,   -8.93514]],\n\n       [[ -18.6896 ,  -57.0662 , -102.733  , ...,   -4.63053,\n          -33.0595 ,  -18.4545 ],\n        [  -4.71529, -167.057  , -299.696  , ...,   -5.00925,\n           -3.97491,  -59.8419 ],\n        [ -75.8    ,   -3.83045, -201.039  , ..., -167.683  ,\n         -186.641  ,  -81.0174 ],\n        ...,\n        [ -12.046  ,  -44.6544 , -129.648  , ...,  -32.7041 ,\n           -9.54657,   -3.67239],\n        [  -2.96314,   -4.2949 ,  -27.2165 , ...,   -4.11057,\n           -3.64532,   -3.89527],\n        [  -8.2396 ,  -22.3636 , -384.246  , ...,  -74.6057 ,\n           -9.58703,  -87.318  ]]])Indexes: (6)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))volume_ls_dim_0PandasIndexPandasIndex(Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23],\n      dtype='int64', name='volume_ls_dim_0'))tubePandasIndexPandasIndex(Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23],\n      dtype='int64', name='tube'))obsPandasIndexPandasIndex(Index([1, 4, 9, 11, 15, 19, 21, 22], dtype='int64', name='obs'))llik_dim_0PandasIndexPandasIndex(Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64', name='llik_dim_0'))Attributes: (4)created_at :2024-04-12T15:47:54.915558arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  sample_stats_prior\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 204kB\nDimensions:          (chain: 4, draw: 1000)\nCoordinates:\n  * chain            (chain) int64 32B 0 1 2 3\n  * draw             (draw) int64 8kB 0 1 2 3 4 5 6 ... 994 995 996 997 998 999\nData variables:\n    lp               (chain, draw) float64 32kB 72.09 71.09 ... 23.28 14.77\n    acceptance_rate  (chain, draw) float64 32kB 0.9856 0.9735 ... 0.9808 0.99\n    step_size        (chain, draw) float64 32kB 0.03423 0.03423 ... 0.04274\n    tree_depth       (chain, draw) int64 32kB 4 4 4 4 4 4 4 4 ... 7 6 7 7 6 6 7\n    n_steps          (chain, draw) int64 32kB 15 31 15 15 15 ... 127 63 63 127\n    diverging        (chain, draw) bool 4kB False False False ... False False\n    energy           (chain, draw) float64 32kB -58.38 -61.21 ... -14.09 -3.941\nAttributes:\n    created_at:                 2024-04-12T15:47:54.918282\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:chain: 4draw: 1000Coordinates: (2)chain(chain)int640 1 2 3array([0, 1, 2, 3])draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([  0,   1,   2, ..., 997, 998, 999])Data variables: (7)lp(chain, draw)float6472.09 71.09 72.54 ... 23.28 14.77array([[72.0913, 71.0934, 72.5368, ..., 22.7741, 19.717 , 31.5704],\n       [78.6388, 67.3879, 66.6947, ..., 27.7493, 23.3811, 21.9996],\n       [32.2751, 29.5342, 31.5931, ..., 21.5172, 20.5746, 25.7496],\n       [19.4916, 19.317 , 10.9252, ..., 36.2183, 23.2776, 14.7731]])acceptance_rate(chain, draw)float640.9856 0.9735 ... 0.9808 0.99array([[0.985585, 0.973493, 0.926252, ..., 0.999961, 0.998114, 0.999975],\n       [0.987531, 0.826221, 0.990511, ..., 0.999879, 0.999778, 0.999777],\n       [0.989942, 0.996745, 0.999915, ..., 0.997515, 0.999232, 0.999938],\n       [0.999604, 0.99648 , 0.998834, ..., 0.999231, 0.980821, 0.99004 ]])step_size(chain, draw)float640.03423 0.03423 ... 0.04274 0.04274array([[0.0342255, 0.0342255, 0.0342255, ..., 0.0342255, 0.0342255,\n        0.0342255],\n       [0.0211665, 0.0211665, 0.0211665, ..., 0.0211665, 0.0211665,\n        0.0211665],\n       [0.0399343, 0.0399343, 0.0399343, ..., 0.0399343, 0.0399343,\n        0.0399343],\n       [0.0427424, 0.0427424, 0.0427424, ..., 0.0427424, 0.0427424,\n        0.0427424]])tree_depth(chain, draw)int644 4 4 4 4 4 4 4 ... 7 7 6 7 7 6 6 7array([[4, 4, 4, ..., 7, 7, 7],\n       [5, 5, 5, ..., 8, 8, 8],\n       [6, 7, 6, ..., 7, 7, 7],\n       [7, 7, 7, ..., 6, 6, 7]])n_steps(chain, draw)int6415 31 15 15 15 ... 127 63 63 127array([[ 15,  31,  15, ..., 127, 255, 127],\n       [ 31,  31,  31, ..., 255, 255, 255],\n       [ 63, 255,  63, ..., 127, 127, 127],\n       [127, 127, 127, ...,  63,  63, 127]])diverging(chain, draw)boolFalse False False ... False Falsearray([[False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False]])energy(chain, draw)float64-58.38 -61.21 ... -14.09 -3.941array([[-5.83823e+01, -6.12113e+01, -6.32211e+01, ..., -1.00715e+01,\n         3.57843e-02, -1.26730e+01],\n       [-7.05147e+01, -5.28132e+01, -5.87134e+01, ..., -1.31417e+01,\n        -1.17634e+01, -5.75708e+00],\n       [-2.44030e+01, -1.81596e+01, -2.17799e+01, ..., -9.25289e+00,\n        -6.95541e+00, -9.89278e+00],\n       [-5.78982e+00, -5.81860e+00, -6.76507e-01, ..., -1.92249e+01,\n        -1.40883e+01, -3.94102e+00]])Indexes: (2)chainPandasIndexPandasIndex(Index([0, 1, 2, 3], dtype='int64', name='chain'))drawPandasIndexPandasIndex(Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n       ...\n       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],\n      dtype='int64', name='draw', length=1000))Attributes: (4)created_at :2024-04-12T15:47:54.918282arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n            \n                  \n                  observed_data\n                  \n                  \n                      \n                          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 896B\nDimensions:               (N_dim_0: 1, N_cal_dim_0: 1, tube: 24, obs: 8,\n                           measurement_ix_dim_0: 8, cal_error_dim_0: 1,\n                           likelihood_dim_0: 1)\nCoordinates:\n  * N_dim_0               (N_dim_0) int64 8B 0\n  * N_cal_dim_0           (N_cal_dim_0) int64 8B 0\n  * tube                  (tube) int64 192B 0 1 2 3 4 5 6 ... 18 19 20 21 22 23\n  * obs                   (obs) int64 64B 1 4 9 11 15 19 21 22\n  * measurement_ix_dim_0  (measurement_ix_dim_0) int64 64B 0 1 2 3 4 5 6 7\n  * cal_error_dim_0       (cal_error_dim_0) int64 8B 0\n  * likelihood_dim_0      (likelihood_dim_0) int64 8B 0\nData variables:\n    N                     (N_dim_0) int64 8B 24\n    N_cal                 (N_cal_dim_0) int64 8B 8\n    target_volume         (tube) int64 192B 200 200 200 200 ... 800 800 800 800\n    y                     (obs) float64 64B 199.1 176.3 281.9 ... 693.9 783.4\n    measurement_ix        (measurement_ix_dim_0) int64 64B 2 5 10 12 16 20 22 23\n    cal_error             (cal_error_dim_0) float64 8B 0.02\n    likelihood            (likelihood_dim_0) int64 8B 1\n    true_volume           (tube) float64 192B 152.6 199.7 161.3 ... 770.5 598.6\nAttributes:\n    created_at:                 2024-04-12T15:47:54.920302\n    arviz_version:              0.17.0\n    inference_library:          cmdstanpy\n    inference_library_version:  1.2.1xarray.DatasetDimensions:N_dim_0: 1N_cal_dim_0: 1tube: 24obs: 8measurement_ix_dim_0: 8cal_error_dim_0: 1likelihood_dim_0: 1Coordinates: (7)N_dim_0(N_dim_0)int640array([0])N_cal_dim_0(N_cal_dim_0)int640array([0])tube(tube)int640 1 2 3 4 5 6 ... 18 19 20 21 22 23array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23])obs(obs)int641 4 9 11 15 19 21 22array([ 1,  4,  9, 11, 15, 19, 21, 22])measurement_ix_dim_0(measurement_ix_dim_0)int640 1 2 3 4 5 6 7array([0, 1, 2, 3, 4, 5, 6, 7])cal_error_dim_0(cal_error_dim_0)int640array([0])likelihood_dim_0(likelihood_dim_0)int640array([0])Data variables: (8)N(N_dim_0)int6424array([24])N_cal(N_cal_dim_0)int648array([8])target_volume(tube)int64200 200 200 200 ... 800 800 800 800array([200, 200, 200, 200, 200, 200, 200, 200, 400, 400, 400, 400, 400,\n       400, 400, 400, 800, 800, 800, 800, 800, 800, 800, 800])y(obs)float64199.1 176.3 281.9 ... 693.9 783.4array([199.07727295, 176.25632772, 281.87757567, 387.16351159,\n       362.14946827, 853.23878527, 693.91934176, 783.39963414])measurement_ix(measurement_ix_dim_0)int642 5 10 12 16 20 22 23array([ 2,  5, 10, 12, 16, 20, 22, 23])cal_error(cal_error_dim_0)float640.02array([0.02])likelihood(likelihood_dim_0)int641array([1])true_volume(tube)float64152.6 199.7 161.3 ... 770.5 598.6array([152.64294349, 199.70810807, 161.32449302, 171.49715397,\n       174.67894069, 163.43175945, 153.50063823, 187.79919405,\n       364.94147086, 289.55488638, 445.13256694, 387.79655766,\n       326.2592979 , 385.23402356, 335.94110379, 349.87019831,\n       761.78380169, 620.86368119, 745.73037525, 809.71007835,\n       803.52489045, 683.21425317, 770.52360505, 598.61585552])Indexes: (7)N_dim_0PandasIndexPandasIndex(Index([0], dtype='int64', name='N_dim_0'))N_cal_dim_0PandasIndexPandasIndex(Index([0], dtype='int64', name='N_cal_dim_0'))tubePandasIndexPandasIndex(Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23],\n      dtype='int64', name='tube'))obsPandasIndexPandasIndex(Index([1, 4, 9, 11, 15, 19, 21, 22], dtype='int64', name='obs'))measurement_ix_dim_0PandasIndexPandasIndex(Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64', name='measurement_ix_dim_0'))cal_error_dim_0PandasIndexPandasIndex(Index([0], dtype='int64', name='cal_error_dim_0'))likelihood_dim_0PandasIndexPandasIndex(Index([0], dtype='int64', name='likelihood_dim_0'))Attributes: (4)created_at :2024-04-12T15:47:54.920302arviz_version :0.17.0inference_library :cmdstanpyinference_library_version :1.2.1\n                      \n                  \n            \n            \n              \n            \n            \n\n\nNext we look at the summaries of both the posterior and prior.\n\nfor group_name in [\"prior\", \"posterior\"]:\n    group = idata.get(group_name)\n    group_summary = az.summary(\n        group,\n        var_names=[\n            \"volume_noise\", \"bias_factor\", \"volume_noise_s\", \"bias_factor_l\"\n        ]\n    )\n    display(group_summary)\n\n\n\n\n\n\n\n\n\nmean\nsd\nhdi_3%\nhdi_97%\nmcse_mean\nmcse_sd\ness_bulk\ness_tail\nr_hat\n\n\n\n\nvolume_noise\n0.066\n0.034\n0.016\n0.128\n0.002\n0.001\n224.0\n380.0\n1.01\n\n\nbias_factor\n0.994\n0.143\n0.731\n1.252\n0.015\n0.010\n80.0\n120.0\n1.06\n\n\nvolume_noise_s\n0.108\n0.055\n0.026\n0.210\n0.003\n0.002\n224.0\n380.0\n1.01\n\n\nbias_factor_l\n-0.016\n0.141\n-0.286\n0.242\n0.015\n0.011\n80.0\n120.0\n1.06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmean\nsd\nhdi_3%\nhdi_97%\nmcse_mean\nmcse_sd\ness_bulk\ness_tail\nr_hat\n\n\n\n\nvolume_noise\n0.113\n0.026\n0.068\n0.160\n0.001\n0.001\n1303.0\n1943.0\n1.0\n\n\nbias_factor\n0.887\n0.055\n0.781\n0.986\n0.001\n0.001\n2493.0\n2380.0\n1.0\n\n\nvolume_noise_s\n0.185\n0.043\n0.111\n0.261\n0.001\n0.001\n1303.0\n1943.0\n1.0\n\n\nbias_factor_l\n-0.122\n0.061\n-0.229\n0.002\n0.001\n0.001\n2493.0\n2380.0\n1.0\n\n\n\n\n\n\n\n\n\n\nInvestigating the results\nThis plot compares the measurements with the observations.\n\naz.plot_lm(\n    y=idata.observed_data[\"y\"],\n    x=idata.observed_data[\"tube\"].sel(tube=MEASUREMENT_IX + 1),\n    y_hat=idata.posterior_predictive[\"y_rep\"]\n)\nax = plt.gca()\nax.semilogy()\n\n\n\n\n\n\n\n\nThis plot compares the volume_noise and bias_factor samples with the true values that we used to simulate the data.\n\naz.plot_posterior(\n  idata.prior,\n  var_names=[\"volume_noise\", \"bias_factor\"],\n  kind=\"hist\",\n  hdi_prob=\"hide\",\n  point_estimate=None,\n  figsize=[12, 4]\n)\nf = plt.gcf()\naxes = f.axes\naz.plot_posterior(\n  idata.posterior,\n  var_names=[\"volume_noise\", \"bias_factor\"],\n  kind=\"hist\",\n  hdi_prob=\"hide\",\n  point_estimate=None,\n  figsize=[12, 4],\n  ax=axes,\n  color=\"tab:orange\"\n)\nfor ax, truth in zip(f.axes, [NOISE, BIAS_FACTOR]):\n    ax.axvline(truth, color=\"red\")\n\n\n\n\n\n\n\n\nThis plot shows the samples for all the tubes’ volumes, including those that weren’t measured, alongside the true volumes.\n\naz.plot_lm(\n    x=idata.observed_data[\"tube\"],\n    y=idata.observed_data[\"true_volume\"],\n    y_hat=idata.posterior[\"volume\"],\n    grid=False,\n    y_kwargs={\"label\": \"true volume\"},\n    figsize=[10, 5],\n    legend=False,\n)\nax = plt.gca()\nfor i in MEASUREMENT_IX:\n    ax.text(i+0.1, volumes[i], \"obs\", zorder=1000)\nax.set(xlabel=\"tube\", ylabel=\"volume ($\\\\mu$l)\");\nax.semilogy()\n\n\n\n\n\n\n\n\nSo, what is the probability that Teddy put less than 350 \\(\\mu\\)l of label into tube 10, even though the target amount was 400\\(\\mu\\)l?\n\naz.plot_posterior(\n  idata.prior,\n  var_names=[\"volume\"],\n  coords={\"tube\": [10]},\n  kind=\"hist\",\n  hdi_prob=\"hide\",\n  point_estimate=None,\n  ref_val=350,\n  figsize=[12, 4],\n  bins=np.linspace(250, 600, 30),\n)\n\n\n\n\n\n\n\n\nPhew, only about 13%, that’s probably fine right?",
    "crumbs": [
      "Course materials",
      "Regression models for describing measurements"
    ]
  }
]